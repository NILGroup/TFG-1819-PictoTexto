% !TeX encoding = ISO-8859-1

\chapter{Pict2Text}
\label{cap:Pict2Text}
A lo largo de este capitulo expondremos la aplicación, Pict2Text que hemos desarrollado para este proyecto. Pict2Text, ver en la Figura \ref{fig:pict2Text}, es una aplicación que permite la traducción de pictogramas a lenguaje natural. Pict2Text posee un buscador de pictogramas, que sirve para obtener los pictogramas con los que construir el mensaje que se desea traducir. El buscador permite hacer búsquedas de los pictogramas de ARAASAC asociados a  una determinada palabra. En la Figura \ref{fig:buscadorPictogramas}, se puede ver el buscador de nuestra aplicación. Cabe destacar que lo ideal sería poder implementar algún tipo de funcionalidad que cargara el mensaje en pictogramas en vez de construirlo, pero dado que el foco de este TFG es la  traducción se decidió implementar un buscador.
\figura{Bitmap/ServiciosWeb/pict2Text}{width=12cm}{fig:pict2Text}{Pict2Text}

A lo largo de este capitulo mostraremos la arquitectura de nuestra aplicación (sección \ref{cap5:sec:Arquitectura})

\figura{Bitmap/Arquitectura/buscadorPictogramas}{width=8cm}{fig:buscadorPictogramas}{Buscador de pictogramas de Pict2Text }
Y detallaremos los diferentes servicios web implementados en la parte Back-End, para dotar de funcionalidad a la aplicación. Por ultimo, explicaremos como hemos implementado la aplicación Front-End de la aplicación con el framework Angular, describiendo los diferentes componentes que la forman y la relación que guardan con la parte Back-End. En la Figura \ref{fig:ServiciosWebDiagrama}, podemos ver un diagrama en el que se muestran las partes Back y Fron-End y su relación.

\figura{Bitmap/Arquitectura/ServiciosWebDiagrama}{height=14cm, width=13cm}{fig:ServiciosWebDiagrama}{Pict2Text visión general }

%------------------------------------------------------------------
\section{Arquitectura}
%-------------------------------------------------------------------
\label{cap5:sec:Arquitectura}

El trabajo de este TFG está englobado dentro del proyecto nacional IDiLyCo\footnote{http://nil.fdi.ucm.es/index.php?q=projects/idilyco}. IDiLyCo es un proyecto que busca facilitar la inclusión digital, de aquellas personas que por diversidad   funcional, tienen problemas con el lenguaje natural. Uno de los objetivos del proyecto es desarrollar pequeñas piezas de funcionalidad reutilizables que se combinan en diferentes aplicaciones, es por ello que  debíamos diseñar una arquitectura con muy bajo acoplamiento. Por esa razón hemos decidido utilizar una arquitectura orientada a servicios en la parte Back-End, y a componentes en la parte Front-end. En ambas casos, hemos seguido los siguientes principios \citep{martin2013agile}: 

\begin{itemize}
\item Principio Open/Closed. Este principio busca que los programas estén abiertos para la extensión y cerrados a la modificación. Esto es que no haga falta modificar el código de nuestras clases para extender su funcionalidad. Esto permite depurar de una manera más eficiente el código y ampliar su funcionalidad con otros métodos. Esto lo podemos ver en el uso de diferentes servicios web, que aportan funcionalidad individualmente evitando el uso de un solo servicio web que implemente toda la funcionalidad, además del proceso de generación de lenguaje donde las clases implementan pequeños métodos que encadenados aportan funcionalidad a la traducción.
   
\item Principio de segregación de la interfaz. Este principio busca abstraer lo máximo posible las interfaces de todas las clases, para así poder re-aprovecharlas en otras clases. Un ejemplo es como hemos implementado en el Front-End, la parte de las llamadas a los Servicios Web del Back-End: todos los componentes de la aplicación hacen uso de la misma clase para lanzar las peticiones a los servicios web.

\item Principio de inversión de dependencias. Consiste en evitar dependencias externas dentro del código, y que el código central de las aplicaciones no dependa de frameworks, de bases de datos o del como se conecten los diferentes servicios entre ellos. Normalmente se habla de que las clases de alto nivel no deben de depender de las clases de bajo nivel\footnote{https://devexperto.com/principio-de-inversión-de-dependencias/}. Un ejemplo de esto en nuestra aplicación es el uso de Servicios Web, que reciben tipos básicos para que estos no estén acoplados a estructuras de datos, puedan ser reutilizados por otras aplicaciones por otros desarrolladores.

\end{itemize}

Estos principios tienen como finalidad crear un producto software de calidad y robusto, gracias al desarrollo de un código ordenado y limpio, otorgando además una gran flexibilidad. Gracias a esto se consigue un producto reutilizable y fácil de mantener gracias al bajo acoplamiento que se obtiene.


%------------------------------------------------------------------
\section{Back-End}
%-------------------------------------------------------------------
\label{cap5:sec:backEnd}
A lo largo de está sección presentaremos los diferentes servicios web desarrollados en el TFG, los cuales hemos decidido agrupar en dos grupos, dependiendo de la finalidad de los mismos. Servicios Web para la Generación de Frases, donde están agrupados todos los servicios web dedicados a la generación de lenguaje y procesamiento del lenguaje y los Servicios Web para la Gestión de Pictogramas donde están englobados aquellos servicios web encargados del uso de la API de ARAASAC, para el tratamiento de los pictogramas.

%------------------------------------------------------------------
\subsection{Servicios Web para la Generación de Frases}
%-------------------------------------------------------------------

Dentro de está subsección hablaremos de los servicios web encargados de la generación de lenguaje natural y procesamiento de lenguaje natural. Dentro del grupo de Servicios Web para la Generación de Frases, están englobados tres servicios web:
\begin{itemize}
\item Servicio Web de Clasificación de Palabras, encargado del procesamiento de lenguaje natural de las palabras.
\item Servicio Web de Detección de Tiempo Verbal, es el encargado de definir el tiempo verbal de la frase resultante.
\item Servicio Web de Generación de Frases en Lenguaje Natural, este servicio web tiene como finalidad la generación de lenguaje natural.
\end{itemize}
%------------------------------------------------------------------
\subsubsection{Servicio Web de Clasificación de Palabras}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioClasificaciónDePalabras}

El servicio web de clasificación de palabras, se encarga de dada una palabra o un array de palabras devolver la categoría léxica (verbo, nombre, adverbio, determinante, adjetivo...) y todos los atributos ( genero, numero, tiempo verbal...) de cada una de las palabras recibidas.
Una vez se tiene la entrada se llama a la  función Tokenizer\footnote{https://spacy.io/api/tokenizer} de la librería Spacy, cabe destacar que esta llamada se hará por cada una de las palabras que se reciba. Para obtener la categorización léxica de la palabra y los atributos de la mismas, los diferentes resultados de este servicio web están reflejados en las tablas \ref{tabla:clasificacion}.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Categoría Léxica & Atributos \\
\hline \hline
Verbo & Forma verbal  \\ \hline
Nombre & Genero, número  \\ \hline
Determinante & Género, numero, tipo de determinante, determinante definido o indefinido \\ \hline
Adjetivo & Género, numero\\ \hline
Pronombre & Género, numero, persona, tipo de pronombre\\ \hline
Adverbio & -\\ \hline
Preposiciones & Tipo de preposiciones\\ \hline
Conjunciones & -\\ \hline
\end{tabular}
\caption{Tabla de características devueltas por el servicio según la categoría léxica.}
\label{tabla:clasificacion}
\end{center}
\end{table}
\figura{Bitmap/ServiciosWeb/attrsResponsePost}{height=18cm, width=7cm}{fig:attrsResponsePost}{Respuesta del servicio web de clasificación de palabras para la entrada [corredor, despistado, perder, zapatillas, ayer].}
\figura{Bitmap/ServiciosWeb/caracPal}{height=10cm}{fig:caracPal}{Flujo del servicio web de clasificación de palabras} 

La salida de la función tokenizer sera procesada para generar el JSON que sera la salida de nuestro sistema. En la Figura \ref{fig:attrsResponsePost}, podemos ver la respuesta del servicio web para la entrada [corredor, despistado, perder, zapatillas, ayer].
En la Figura \ref{fig:caracPal}, podemos ver un resumen del flujo que sigue este servicio.


%------------------------------------------------------------------
\subsubsection{Servicio Web de Detección de Tiempo Verbal}
%-------------------------------------------------------------------
\label{cap5:sec:ServiciodeDeteccióndeTiempoVerbal}

Este servicio web, tiene como finalidad determinar el tiempo verbal de una frase dado la lista de palabras que conforman la frase. Este servicio busca las palabras temporales, ayer, hoy o mañana en el array de palabras recibido como entrada. Si encuentra alguna de estas palabras devuelve el tiempo verbal correspondiente, pasado si encontró ayer, presente si encontró hoy y futuro si encontró mañana. En caso de no encontrar ninguna de las 3 palabras devuelve presente por defecto. 
\figura{Bitmap/ServiciosWeb/deteccionTiempoVerbal}{width=100px}{fig:deteccionTiempoVerbal}{Flujo del servicio web de detección del tiempo verbal} 
\figura{Bitmap/ServiciosWeb/timeDeteccion}{width=100px}{fig:timeDeteccion}{respuesta del servicio web de detección del tiempo verbal para la entrada [corredor, despistado, perder, zapatillas, ayer]} 
En la Figura \ref{fig:deteccionTiempoVerbal}, podemos ver un resumen del flujo que sigue este servicio y en las Figura \ref{fig:timeDeteccion} podemos ver un ejemplo de salida para la entrada [corredor, despistado, perder, zapatillas, ayer].

%------------------------------------------------------------------
\subsubsection{Servicio Web de Generación de Frases en Lenguaje Natural}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioGLN}

Este servicio web recibe un array de strings y devuelve una frase creada a partir de las palabras recibidas en la llamada. Los pasos seguidos por el servicio para crear la frase de salida son los siguiente:

\begin{enumerate}

\item Obtención de la categoría léxica de cada una de las palabras: Se llama al Servicio Web de Clasificación de Palabras explicado en la sección \ref{cap5:sec:ServicioClasificaciónDePalabras}, utilizando el metodo POST que permite enviar todo el array de palabras, para obtener las características y la categoría léxica de cada palabra.

\item División de palabras en sintagma nominal y en sintagma verbal: una vez conocemos la categoría léxica de las palabras, buscamos el verbo dentro del array de palabras. Todas las palabras anteriores al verbo formaran el sintagma nominal y todas las posteriores el sintagma verbal.

\item Una vez identificadas las palabras que forman parte del sujeto se pasa a procesar el sujeto de la frase.

\begin{itemize}
\item Creación del objeto sujeto: gracias a la función \textbf{createNounPhrase()} de la librería SimpleNLG, creamos el sintagma nominal que sera el objeto contenedor de todas las palabras que formaran el sujeto.
 
\item Selección del determinante: En este proceso se establecerá el determinante del sujeto, utilizando la función \textbf{setDeterminer(``determinante'')} de SimpleNLG, sobre el objeto creado anteriormente. En caso de que la lista de palabras que formaran el sujeto, no contenga un pronombre o un determinante, se añade el determinante por defecto(``el''). En caso contrario la se añadirá el determinante o pronombre, en lugar del determinante de por defecto.

\item Genero y número: una vez se encuentra una palabra de categoría lexica nombre, se establece como palabra principal del sujeto utilizando el método textbf{setFeature(``nombre''))} además se obtiene su genero y numero y se aplica al sujeto usando las funciones \textbf{setFeature(LexicalFeature.GENDER, Gender.FEMININE)} y \textbf {setPlural(``esPlural'')} respectivamente. Cabe destacar que por defecto el genero y numero de cualquier frase nominal es masculino singular, y solo se establecerá el genero del sujeto en caso de que deba ser femenino. Al establecer el genero y numero del sujeto todas las palabras que lo conforman utilizaran ese genero y numero,  por ejemplo  ``mujeres, contento'' el sujeto resultante sera ``Las mujeres contentas''. Dado que todos los pictogramas no existen en femenino, hemos desarrollado una lógica que en caso de existir un determinante con genero, el sujeto tendrá ese genero.

\item En caso de encontrar un adverbio dentro del array de palabras se fuerza su posición dentro del sujeto al final del sujeto. Por ejemplo, para la entrada [``ayer, profesora, despistada, comer, galletas, duro''] se generara la frase ``La profesora despistada ayer comió galletas duras''
\end{itemize}

\item De la misma manera que con el sujeto, se genera un objeto que sera el sintagma verbal. Se recorren todas las palabras que formaran el predicado y se aplica la misma lógica para seleccionar el determinante que en el sujeto, con la diferencia de que el determinante por defecto es ``un'', y solo se añadirá en caso de que exista una palabra con categoría léxica nombre. De manera que si el array está formado por las palabras ``galletas, duro'' el resultado sera ``unas galletas duras''. Además si existe un nombre se aplicara su genero y numero al sintagma verbal. 
Si existe un adverbio se fuerza su posición al final de la frase, de manera que si las palabras que conformaran la frase final contienen ``profesora, comer, ayer, galletas, duro'', la frase resultante sera ``La profesora comió galletas duras ayer''. 

\item A continuación se hace una llamada al Servicio Web de Detección de Tiempo Verbal, para obtener el tiempo verbal el que se debe conjugar la frase resultante.

\item Para terminar creamos un objeto frase de la biblioteca simpleNLG con \textbf{SPhraseSpec(``phraseFactory'')}. Utilizando la función \textbf{.setSubject(``subject'')}, añadimos el sujeto creado previamente. En caso de tener verbo lo añadiremos utilizando \textbf{setVerbPhrase.(``verb'')} y seleccionaremos el tiempo verbal de la frase, en caso de que no sea presente usaremos las funciones \textbf{setFeature(Feature.TENSE, Tense.FUTURE) o setFeature(Feature.TENSE, Tense.PAST)}, para definir el tiempo verbal en futuro o pasado respectivamente. Una vez tenemos todos la frase formada se pasa a la realización de la misma, utilizando el objeto \textbf{Realiser} de SimpleNlG, y se guardara en una variable el resultado.
Esta variable sera la respuesta de este servicio web.

\end{enumerate}
En la Figura \ref{fig:NLGService}, podemos ver un resumen del flujo que sigue este servicio.
\figura{Bitmap/ServiciosWeb/NLGService}{width=350px}{fig:NLGService}{Flujo del Servicio Web de Detección de Generación de Frases en Lenguaje Natural} y en la tabla \ref{tabla:tiempoVerbal} podemos varios ejemplos de entradas y salidas del servicio.

\begin{table}[htbp]
\begin{tabular}{p{4cm}p{8cm}}
\hline
Entrada & Salida \\
\hline \hline
Corredor, perder, zapatillas & El corredor pierde unas zapatillas\\ \hline
Corredor, rápido, perder, zapatillas & El corredor rápido pierde unas zapatillas\\ \hline
Corredor, ayer, perder, zapatillas & El corredor ayer perdió unas zapatillas.\\ \hline
Corredor, mañana, perder, zapatillas & El corredor mañana perderá unas zapatillas.\\ \hline
Corredor, rápido, ayer, perder, zapatillas & El corredor rápido ayer perdió unas zapatillas.\\ \hline
Corredor, perder, zapatillas, nuevo & El corredor pierde unas zapatillas nuevas\\ \hline
Corredor, rápido, perder, zapatillas, nuevo & El corredor rápido pierde unas zapatillas nuevas\\ \hline
Corredor, rápido, ayer, perder, zapatillas, nuevo & El corredor rápido ayer perdió unas zapatillas nuevas.
\\ \hline
Corredor, rápido. perder, zapatillas, nuevo, ayer & El corredor rápido perdió unas zapatillas nuevas ayer.
\\ \hline
Este, corredor, rápido, perder, zapatillas, nuevo & Este corredor rápido ayer perdió unas zapatillas nuevas.
\\ \hline
La, corredor, rápido, perder, zapatillas, nuevo & La corredora rápida ayer perdió unas zapatillas nuevas.
\\ \hline
\end{tabular} 
\caption{Tabla con diferentes entradas y salidas del Servicio Web de Generación de Frases en Lenguaje Natural.}
\label{tabla:tiempoVerbal}
\end{table}

%------------------------------------------------------------------
\subsection{Servicios Web para la Gestión de Pictogramas} %-------------------------------------------------------------------
\label{cap5:sec:ServiciosParaPictos}

En esta subsección pasaremos a explicar los dos servicios web, que hemos creado para tratar con pictogramas. En estos servicios hemos utilizando la API de ARASAAC\footnote{https://beta.arasaac.org/developers/api}. Ambos servicios  siguen la misma linea de ejecución, la cual se muestra en la Figura \ref{fig:serviciosAPIARAASAC}. 
\figura{Bitmap/ServiciosWeb/serviciosAPIARAASAC}{width=200px}{fig:serviciosAPIARAASAC}{Flujo de los Servicios Web Para Pictogramas } 

\subsubsection{Servicio Web de Búsqueda del Pictogramas Asociados a una Palabra}
\label{cap5:sec:ServiciosParaPictosPalabra}
Este servicio web, recibe una palabra a través de una petición GET y devuelve un objeto en formato JSON, con un array con los diferentes pictogramas asociados a la palabra recibida.
Este servicio lanza una petición GET con la palabra recibida, al buscador de pictogramas de la API de ARAASAC\footnote{https://api.arasaac.org/api/pictograms/api/pictograms/es/search/'Nombre'}, el cual devuelve una lista de todos los pictogramas, que tienen asociada la palabra introducida.
La respuesta devuelta por la API de ARAASAC es procesada por nuestro servicio, eliminando los resultados que no son deseados, escogiendo aquellos pictogramas que tienen asociados exclusivamente la palabra introducida, por ejemplo si se realiza la búsqueda huevo, la API de ARAASAC devolverá tres pictogramas: huevo, huevo frito, huevo roto, por lo que los dos últimos se excluirán. Por cada pictograma se devuelven los siguientes atributos:
\begin{itemize}
\item Identificador del pictograma.
\item URL externa a la imagen del pictograma.
\item El significado del pictograma.
\end{itemize}
\figura{Bitmap/ServiciosWeb/pictoFinderResponse}{height=15cm,width=12cm}{fig:pictoFinderResponse}{Respuesta del servicio web de búsqueda del pictogramas asociados a una palabra}
Cada objeto se añade a una lista que sera devuelta en el resultado de este servicio web tal y como podemos ver en la Figura \ref{fig:pictoFinderResponse}, para la entrada ``huevo''.
 

\subsubsection{Servicio Web de Traducción de Pictogramas a Texto}

Este servicio web recibe un identificador de un pictograma y devuelve las diferentes palabras asociadas al pictograma.
Este servicio lanza una petición GET con el identificador recibido, lanza una petición al buscador de pictogramas por id de la API de ARASAAC\footnote{https://api.arasaac.org/api/pictograms/es/`idPictograma'}. En la Figura \ref{fig:finderIDAPI} podemos ver la respuesta para el Identificador 7823.

\figura{Bitmap/ServiciosWeb/finderIDAPI}{width=300px}{fig:finderIDAPI}{Respuesta del buscador por id de la API de ARAASAC} 

Con la respuesta de la API, se accede a su atributo ``Keywords'', se encapsula dentro de un objeto, que sera la respuesta de este servicio tal y como se puede ver en la Figura \ref{fig:responseTranslatePictoService}.

\figura{Bitmap/ServiciosWeb/responseTranslatePictoService}{width=300px}{fig:responseTranslatePictoService}{Respuesta del buscador por id de la API de ARAASAC} 

%------------------------------------------------------------------
\section{Front-end}
%-------------------------------------------------------------------
\label{cap5:sec:ComponentesAngular}

En esta sección introduciremos los diferentes servicios y componentes Angular desarrollados para la parte Front-End de la aplicación, la cual podemos ver en la \ref{fig:appEscritorio}. Hemos implementado diferentes componentes:
\begin{itemize}
\item Buscador de pictogramas: el cual podemos ver en la Figura \ref{fig:buscadorPictogramas}, este componente sirve como entrada de pictogramas a la aplicación, en el podemos ver los diferentes pictogramas asociados a la palabra introducida además del identificador de dicho pictograma.
\figura{Bitmap/Arquitectura/buscadorPictogramas}{width=8cm}{fig:buscadorPictogramas}{Componente buscador de pictogramas}
\item Traductor de pictogramas a lenguaje natural: podemos ver este componente en la Figura  \ref{fig:traductorPictogramas}
\figura{Bitmap/Arquitectura/traductorPictogramas}{width=9cm}{fig:traductorPictogramas}{Componente buscador de pictogramas}, este componente es el encargado de manejar los pictogramas que se van a traducir, dentro de el podemos ver los pictogramas que formaran la frase, ordenarlos o borrar aquellos que no se desean.
\end{itemize}
un buscador de pictogramas, un traductor de pictograma por id, y el componente traductor de pictogramas, que sirve de contenedor para los diferentes pictogramas que vamos a traducir. Cabe destacar que cada uno de estos componentes posee un html, controlador y servicio de aplicación propio.  A parte de estos componentes hemos implementado una serie de útiles, como un archivo de constantes, para almacenar las diferentes direcciones de los servicios web, un servicio proxy que permite abstraer las peticiones HTTP, y por ultimo otro servicio de ventanas modales para el tratamiento de errores.
Ademas hemos tenido en cuenta que la aplicación sea responsive y diseñado la vista para tener una versión móvil la cual se puede ver en la Figura \ref{fig:appMo}.

\figura{Bitmap/Arquitectura/appEscritorio}{width=430px}{fig:appEscritorio}{Pict2Text}
\figura{Bitmap/Arquitectura/appMo}{height=15cm}{fig:appMo}{Pict2Text versión para dispositivos moviles}
\subsection{Servicio Proxy}

El servicio proxy de la aplicación Angular sirve para abstraer las diferentes llamadas HTTP del resto de la aplicación, este componente es necesario ya que sirve de punto de acceso a los Servicios Web explicados en la sección Back-End \ref{cap5:sec:backEnd}, de este capitulo. Los  métodos: \textbf{getByName()} y \textbf{postByName()} se encargan de emitir las peticiones HTTP GET y POST respectivamente, esperar la respuesta del servicio web y devolverla al servicio de aplicación. La ventaja principal de usar un servicio proxy es que abstrae la logica de acceso del resto de la aplicación, de manera que si los datos pasaran a estar en una base de datos habría que cambiar mucho menos lógica y además permite la reutilización del código de las llamadas HTTP en toda la aplicación.
Cuando un servicio de aplicación de la aplicación llama a un método del servicio proxy, se convierte en un subscriptor de dicho método. Gracias a la suscripción cuando el Servicio Proxy reciba la respuesta de la llamada HTTP, se encargara de avisar a sus suscriptores de que ya ha recibido la respuesta y entregarla. Esto es gracias al patrón Observer que implementa Angular en las llamadas HTTP. En caso de que la respuesta de la llamada fuera un error, el servicio proxy reintentará la llamada hasta cinco veces, si la ultima llamada falla, devuelve el error a los suscriptores. En la Figura \ref{fig:proxyClassDiagram} podemos ver los métodos disponibles en la clase ProxyService.
\figura{Bitmap/Arquitectura/proxyService}{width=200px}{fig:proxyClassDiagram}{Diagrama de clase del Servicio Proxy}

\subsection{Servicio de Ventanas Modales}  
\figura{Bitmap/Arquitectura/modalErrorServiceExample}{width=400px}{fig:errorModalExample}{Ejemplo de ventana modal para un error del tipo 404}
Este servicio tiene como finalidad mostrar los errores que hayan podido surgir a lo largo del flujo de la aplicación, por ejemplo si al buscar una pictograma en la base de datos no se obtiene ningún resultado tal y como podemos ver en la Figura \ref{fig:errorModalExample}. El servicio de ventanas modales, es un componente reutilizable que se inyecta en los componentes, esto nos permite reutilizar toda la lógica necesaria para mostrar los errores en una clase, de la cual hacen uso todas los controladores de la aplicación Front-End. 
Su utilidad principal es construir y mostrar una ventana modal genérica, dado un error especifico, con el fin de dar al usuario feedback de los errores que puedan darse. Sigue el patrón Factory, es decir es capaz de crear objetos concretos, gracias a sus datos de entrada, utilizando una plantilla genérica, tal y como podemos ver en la Figura \ref{fig:errorModalExample}. Además de esto hemos utilizado la librería NGBoostrap\footnote{https://ng-bootstrap.github.io/} para la implementación de este servicio de ventanas modales, esta librería hace uso del patrón Singleton para las ventanas modales, y ademas abstrae toda la funcionalidad relacionada con el uso de ventanas modales, como pueda ser la lógica de abrir o cerrar la ventana. Además de la funcionalidad tiene estilos CSS propios, que ayudan a definir el tamaño de la ventana modal, el fondo que se pone sobre el body de la pagina, etc. 
Este servicio tiene dos variables de entrada el código de error y el texto asociado al error, ambos obtenidos del error devuelto por el servicio. En la Figura \ref{fig:modalErrorServiceClass}, podemos ver un diagrama que resume los métodos de la clase ErrorModalService, y muestra su dependencia con la plantilla Error-Modal.html, la cual es usada para generar las ventanas modales.
\figura{Bitmap/Arquitectura/modalErrorServiceClass}{width=200px}{fig:modalErrorServiceClass}{Diagrama del servicio de modales}

\subsection{Buscador de Pictogramas}
La utilidad principal del buscador de pictogramas es ser el punto de entrada de los pictogramas a la aplicación, dado que no existe ningún otro punto de acceso, como pueda ser un archivo con diferentes pictogramas. El componente esta formado por un input donde introducir la palabra para la que se desea buscar el pictograma y un carrusel de pictogramas que permanece oculto hasta que se busca un pictograma y que nos permite mostrar todos los pictogramas asociados con la palabra introducida .El carrusel ha sido implementado con la librería NGBoostrap.
Este componente posee un controlador, un servicio de aplicación propios y un transformer.

El controlador es el encargado de conectar el HTML de la vista, con el resto de la aplicación Angular. Tiene sirve para obtener la palabra para la que se desea buscar un pictograma que se desea buscar y enviarlo al servicio de aplicación y además añadir los pictogramas al componente traductor de pictogramas usando el botón añadir.
 
El servicio de aplicación creara la URL para hacer la llamada al servicio web de búsqueda del pictogramas asociados a una palabra (visto en la sección \ref{cap5:sec:ServiciosParaPictosPalabra}) usando el archivo de constantes. Con la URL generada llamara al Servicio Proxy, que se encargara de enviar y recibir la respuesta del servicio web. Si la respuesta es correcta el servicio de aplicación hará uso del transformer para generar un objeto para el controlador, en caso de error devolverá el error al controlador para que muestre el mensaje de error.
Podemos ver el diagrama del componente buscador de pictogramas en la Figura \ref{fig:finderClass}.    
\figura{Bitmap/Arquitectura/finderClass}{width=300px}{fig:finderClass}{Diagrama del componente buscador de pictogramas}

\subsection{Traductor de Pictogramas a Lenguaje Natural} 

Este componente sirve de contenedor del array de pictogramas que después traduciremos y para lanzar la traducción, podemos ver este componente en la Figura \ref{fig:traductorPictogramas}.
En el HTML el componente implementa un contenedor para los pictogramas, donde se muestran la frase de pictogramas, este contenedor se ha implementado usando la biblioteca Material de Angular\footnote{https://material.angular.io/}. Además el componente tiene un botón para lanzar la traducción y la sección donde se mostrara el resultado de la traducción. 
Este componente tiene un controlador y un servicio de aplicación propio.
El controlador se encarga de manejar la logica drag and drop que posee el contenedor de pictogramas, y la lógica de borrado de los pictogramas.
\figura{Bitmap/Arquitectura/translatorComponent}{width=300px}{fig:translatorComponent}{Diagrama del Traductor de Pictogramas a Lenguaje Natural}
En la Figura \ref{fig:translatorComponent}, podemos ver un diagrama que muestras las clases que forman este componente así como los archivos HTML que contienen el código de la vista.

El servicio de aplicación, tiene como parametro de entrada el array de strings que formara el cuerpo de la petición POST, además obtiene la URL del Servicio de Generación de Lenguaje del archivo de constantes, y usando estos datos llamara al servicio proxy, el cual sera encargado de lanzar la petición POST y devolver la respuesta del servicio. Una vez se obtiene la respuesta del servicio se devuelve la respuesta al controlador del componente, el cual ya sera el encargado de mostrar la traducción o mostrar la ventana de la modal de error en caso de error en la respuesta del servicio.


