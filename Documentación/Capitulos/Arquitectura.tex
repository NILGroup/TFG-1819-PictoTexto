% !TeX encoding = ISO-8859-1

\chapter{Pict2Text}
\label{cap:Pict2Text}
A lo largo de este capitulo expondremos la aplicación, Pict2Text que hemos desarrollado para este proyecto. Pict2Text, ver en la Figura \ref{fig:pict2Text}, es una aplicación que permite la traducción de pictogramas a lenguaje natural. Pict2Text posee un buscador de pictogramas, que sirve para obtener los pictogramas con los que construir el mensaje que se desea traducir. El buscador permite hacer búsquedas de los pictogramas de ARAASAC asociados a  una determinada palabra. En la Figura \ref{fig:buscadorPictogramas}, se puede ver el buscador de nuestra aplicación. Cabe destacar que lo ideal sería poder implementar algún tipo de funcionalidad que cargara el mensaje en pictogramas en vez de construirlo, pero dado que el foco de este TFG es la  traducción se decidió implementar un buscador.
\figura{Bitmap/ServiciosWeb/pict2Text}{height=13cm, width=13cm}{fig:pict2Text}{Pict2Text}

A lo largo de este capitulo mostraremos la arquitectura de nuestra aplicación (sección \ref{cap5:sec:Arquitectura})

\figura{Bitmap/Arquitectura/buscadorPictogramas}{width=8cm}{fig:buscadorPictogramas}{Buscador de pictogramas de Pict2Text }
Y detallaremos los diferentes servicios web implementados en la parte Back-End, para dotar de funcionalidad a la aplicación. Por ultimo, explicaremos como hemos implementado la aplicación Front-End de la aplicación con el framework Angular, describiendo los diferentes componentes que la forman y la relación que guardan con la parte Back-End. En la Figura \ref{fig:ServiciosWebDiagrama}, podemos ver un diagrama en el que se muestran las partes Back y Fron-End y su relación.

\figura{Bitmap/Arquitectura/ServiciosWebDiagrama}{height=14cm, width=13cm}{fig:ServiciosWebDiagrama}{Pict2Text visión general }

%------------------------------------------------------------------
\section{Arquitectura}
%-------------------------------------------------------------------
\label{cap5:sec:Arquitectura}

El trabajo de este TFG está englobado dentro del proyecto nacional IDiLyCo\footnote{http://nil.fdi.ucm.es/index.php?q=projects/idilyco}. IDiLyCo es un proyecto que busca facilitar la inclusión digital, de aquellas personas que por diversidad   funcional, tienen problemas con el lenguaje natural. Uno de los objetivos del proyecto es desarrollar pequeñas piezas de funcionalidad reutilizables que se combinan en diferentes aplicaciones, es por ello que  debíamos diseñar una arquitectura con muy bajo acoplamiento. Por esa razón hemos decidido utilizar una arquitectura orientada a servicios en la parte Back-End, y a componentes en la parte Front-End. En ambas casos, hemos seguido los siguientes principios \citep{martin2013agile}: 

\begin{itemize}
\item Principio Open/Closed. Este principio busca que los programas estén abiertos para la extensión y cerrados a la modificación. Esto es que no haga falta modificar el código de nuestras clases para extender su funcionalidad. Esto permite depurar de una manera más eficiente el código y ampliar su funcionalidad con otros métodos. Esto lo podemos ver en el uso de diferentes servicios web, que aportan funcionalidad individualmente evitando el uso de un solo servicio web que implemente toda la funcionalidad, además del proceso de generación de lenguaje donde las clases implementan pequeños métodos que encadenados aportan funcionalidad a la traducción.
   
\item Principio de segregación de la interfaz. Este principio busca abstraer lo máximo posible las interfaces de todas las clases, para así poder re-aprovecharlas en otras clases. Un ejemplo es como hemos implementado en el Front-End, la parte de las llamadas a los servicios web del Back-End: todos los componentes de la aplicación hacen uso de la misma clase para lanzar las peticiones a los servicios web.

\item Principio de inversión de dependencias. Consiste en evitar dependencias externas dentro del código, y que el código central de las aplicaciones no dependa de frameworks, de bases de datos o del como se conecten los diferentes servicios entre ellos. Normalmente se habla de que las clases de alto nivel no deben de depender de las clases de bajo nivel\footnote{https://devexperto.com/principio-de-inversión-de-dependencias/}. Un ejemplo de esto en nuestra aplicación es el uso de servicios web, que reciben tipos básicos para que estos no estén acoplados a estructuras de datos, puedan ser reutilizados por otras aplicaciones por otros desarrolladores.

\end{itemize}

Estos principios tienen como finalidad crear un producto software de calidad y robusto, gracias al desarrollo de un código ordenado y limpio, otorgando además una gran flexibilidad. Gracias a esto se consigue un producto reutilizable y fácil de mantener gracias al bajo acoplamiento que se obtiene.


En nuestra aplicación por tanto hay dos grandes partes diferenciadas tal y como se puede ver en la Figura \ref{fig:ServiciosWebDiagrama} : 
\begin{itemize}
\item Back-End: Conjunto de servicios web implementados en Java y Python que dotan de funcionalidad a la aplicación.
\item Front-End: aplicación web basada en componentes usando Angular.
\end{itemize}

En las próximas secciones explicaremos en detalle cada una de estas partes.
%------------------------------------------------------------------
\section{Back-End}
%-------------------------------------------------------------------
\label{cap5:sec:backEnd}
A lo largo de está sección presentaremos los diferentes servicios web desarrollados en el TFG, los cuales hemos decidido agrupar en dos grupos, dependiendo de la finalidad de los mismos: servicios web para PLN ( Procesamiento de Lenguaje Natural), donde están agrupados todos los servicios web dedicados a la generación de lenguaje y análisis del lenguaje y los servicios web para la Gestión de Pictogramas donde están englobados aquellos servicios que tratan con pictogramas.

%------------------------------------------------------------------
\subsection{Servicios web para PLN}
%-------------------------------------------------------------------

Dentro de está subsección hablaremos de los servicios web encargados del Procesamiento de Lenguaje Natural(PLN). Dentro de este grupo están englobados tres servicios web:
\begin{itemize}
\item Servicio Web de Clasificación de Palabras\footnote{https://holstein.fdi.ucm.es/tfg-pict2text/translate/getWordAttrs}: encargado de obtener la categoría léxica de un conjunto de palabras.
\item Servicio Web de Detección del Tiempo Verbal\footnote{https://holstein.fdi.ucm.es/tfg-pict2text/translate/getTypePhrase}: encargado de definir el tiempo verbal de un conjunto de palabras.
\item Servicio Web de Generación de Frases \footnote{https://holstein.fdi.ucm.es/tfg-pict2text/NLGWebService/createPhrase}: encargado de la generación de una frase en lenguaje natural a partir de un conjunto de palabras.
\end{itemize}
%------------------------------------------------------------------
\subsubsection{Servicio Web de Clasificación de Palabras}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioClasificaciónDePalabras}

El servicio web de clasificación de palabras, se encarga de dada una palabra o un array de palabras devolver su categoría léxica (verbo, nombre, adverbio, determinante, adjetivo, pronombre, números, conjunciones) y todos sus atributos de cada una de las palabras recibidas.

Una vez se tiene la entrada se llama a la clase Tokenizer\footnote{https://spacy.io/api/tokenizer} de la librería Spacy. Para cada palabra ademas de la categoría léxica obtenemos los atributos mostrados en la tabla \ref{tabla:clasificacion}, según la categoría léxica de la palabra los atributos obtenidos pueden variar.
\begin{center}
\begin{table}[htbp]
\begin{tabular}{|l|l|l|l|}
\hline
Categoría Léxica & Atributos \\
\hline \hline
Verbo & Forma verbal  \\ \hline
Nombre & Género, número  \\ \hline
Determinante & Género, número, tipo, definido o indefinido \\ \hline
Adjetivo & Género, número\\ \hline
Pronombre & Género, número, persona, tipo\\ \hline
Adverbio & -\\ \hline
Preposiciones & Tipo\\ \hline
Conjunciones & -\\ \hline
\end{tabular}
\caption{Tabla de atributos devueltos por el servicio según la categoría léxica de la palabra.}
\label{tabla:clasificacion}
\end{table}
\end{center}

\figura{Bitmap/ServiciosWeb/attrsResponsePost}{height=18cm, width=7cm}{fig:attrsResponsePost}{Respuesta del servicio web de clasificación de palabras para la entrada [corredor, despistado, perder, zapatillas, ayer].}
\figura{Bitmap/ServiciosWeb/caracPal}{height=10cm}{fig:caracPal}{Flujo del servicio web de clasificación de palabras} 

La salida de la clase Tokenizer sera procesada para generar el JSON que sera la salida de nuestro sistema. En la Figura \ref{fig:attrsResponsePost}, podemos ver la respuesta del servicio web para la entrada [corredor, despistado, perder, zapatillas, ayer].
En la Figura \ref{fig:caracPal}, podemos ver un resumen del flujo que sigue este servicio.


%------------------------------------------------------------------
\subsubsection{Servicio Web de Detección de Tiempo Verbal}
%-------------------------------------------------------------------
\label{cap5:sec:ServiciodeDeteccióndeTiempoVerbal}

Este servicio web, tiene como finalidad determinar el tiempo verbal de una frase dado la lista de palabras que conforman la frase. Este servicio busca las palabras temporales, ayer, hoy o mañana en el array de palabras recibido como entrada y si encuentra alguna devuelve el tiempo verbal que corresponda a la palabra temporal encontrada, pasado si encontró ayer, presente si encontró hoy y futuro si encontró mañana. En caso de no encontrar ninguna de las 3 palabras devuelve presente por defecto. 
\figura{Bitmap/ServiciosWeb/deteccionTiempoVerbal}{height=9cm}{fig:deteccionTiempoVerbal}{Flujo del servicio web de detección del tiempo verbal} 
\figura{Bitmap/ServiciosWeb/timeDeteccion}{height=2cm}{fig:timeDeteccion}{JSON de salida del servicio web de detección del tiempo verbal para la entrada [corredor, despistado, perder, zapatillas, ayer]} En la Figura \ref{fig:deteccionTiempoVerbal}, podemos ver un resumen del flujo que sigue este servicio y en las Figura \ref{fig:timeDeteccion} podemos ver un ejemplo de salida para la entrada [corredor, despistado, perder, zapatillas, ayer].

%------------------------------------------------------------------
\subsubsection{Servicio Web de Generación de Frases}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioGLN}

Este servicio web recibe un array de palabras y devuelve una frase creada a partir de las palabras recibidas en la llamada. Los pasos seguidos por el servicio para crear la frase de salida son los siguiente:

\begin{enumerate}

\item Obtención de la categoría léxica de cada una de las palabras: Se llama al Servicio Web de Clasificación de Palabras explicado en la sección \ref{cap5:sec:ServicioClasificaciónDePalabras}, pansandole todo el array de palabras recibido como entrada, para obtener las características y la categoría léxica de cada palabra.

\item División de palabras en sintagma nominal y en sintagma verbal: una vez conocemos la categoría léxica de las palabras, buscamos el verbo dentro del array de palabras. Todas las palabras anteriores al verbo formaran el sintagma nominal y todas las posteriores el sintagma verbal.

\item Una vez identificadas las palabras que forman parte del sintagma nominal se pasa a crear esta parte de la frase para ello se hace lo siguiente:

\begin{itemize}
\item Creamos el sintagma nominal que sera el objeto contenedor de todas las palabras que formaran el sujeto llamando la función \textbf{createNounPhrase()} de la librería SimpleNLG.
 
\item Se establece el determinante del sujeto utilizando la función \textbf{setDeterminer} de SimpleNLG, sobre el objeto creado anteriormente. En caso de que la lista de palabras que forman el sujeto, no contenga un pronombre o un determinante se añade el determinante por defecto ``el'', dado que SimpleNLG no añade ningún determinante. En caso contrario se añadirá el determinante o pronombre de la lista de palabras dado que solo permite tener un determinante o pronombre por cada objeto creado por la función \textbf{createNounPhrase()}, de manera que si la entrada es ``perro'', la salida sería ``el perro'' y si la entrada es ``nuestro, perro'' la salida sera ``nuestro perro''.

\item Se establece como palabra principal del sujeto la palabra con categoría léxica \textbf{NOUN}, utilizando el método \textbf{setFeature())}. Además se obtiene el género y número de la palabra principal del sujeto y usando las funciones \textbf{setFeature()} y \textbf {setPlural()}, se establecen como género y número del sintagma nominal. Cabe destacar que por defecto el género y número de cualquier frase nominal es masculino singular, y solo se establecerá el género del sujeto en caso de que deba ser femenino o plural. Al establecer el género y número del sujeto todas las palabras que lo conforman utilizaran ese género y número,  por ejemplo  ``mujeres, contento'' el sujeto resultante sera ``Las mujeres contentas''. Dado que no todas las palabras tienen pictogramas asociados para los diferentes géneros o número, en caso de existir un determinante con género o número,se establecerá dicho género para todo el sintagma.

\item En caso de encontrar un adverbio dentro del array de palabras del sintagma nominal se fuerza su posición dentro del sintagma nominal al final. Por ejemplo, para la entrada [ayer, profesora, despistada, comer, galletas] se generara la frase ``La profesora despistada ayer comió galletas''
\end{itemize}

\item De la misma manera que con el sujeto, existe una lógica para la creación del sintagma verbal.
\begin{itemize}
\item Se genera un objeto que sera el sintagma verbal, con la función \textbf{createNounPhrase()}.
\item Se añade el determinante con una lógica parecida al sujeto, con la diferencia de que el determinante por defecto es ``un'', y solo se añadirá en caso de que exista una palabra con categoría léxica \textbf{NOUN}. De manera que si el array está formado por las palabras ``galletas, duro'' el resultado sera ``unas galletas duras''.
\item En caso de existir una palabra con categoría léxica \textbf{NOUN}, se aplicara su género y número al sintagma verbal, en caso de no existir se aplicara el género y número del sintagma nominal.
\item Si existe un adverbio se fuerza su posición al final de la frase, de manera que si las palabras que conformaran la frase final contienen ``profesora, comer, ayer, galletas, duro'', la frase resultante sera ``La profesora comió galletas duras ayer''. 
\end{itemize}


\item Se hace una llamada al Servicio Web de Detección de Tiempo Verbal con todas las palabras que formaran la frase final, para obtener el tiempo verbal el que se debe conjugar la frase resultante, y guardaremos el resultado para el ultimo paso.

\item Para terminar creamos un objeto frase de la biblioteca simpleNLG con \textbf{SPhraseSpec}. Utilizando la función \textbf{.setSubject}, añadimos el sujeto creado previamente. En caso de tener verbo lo añadiremos utilizando \textbf{setVerbPhrase} y seleccionaremos el tiempo verbal de la frase, en caso de que no sea presente usaremos las funciones \textbf{setFeature(Feature.TENSE, Tense.FUTURE) o setFeature(Feature.TENSE, Tense.PAST)}, para definir el tiempo verbal en futuro o pasado respectivamente.

\item Una vez tenemos todos la frase formada se pasa a la realización de la misma. Este proceso de realización utiliza el objeto \textbf{Realiser} de SimpleNlG para devolver un string que contendra una frase construida utilizando los datos del punto. El resultado se guardara en una variable la cual sera la respuesta de este servicio web.
\end{enumerate}

\figura{Bitmap/ServiciosWeb/NLGService}{height=18cm}{fig:NLGService}{Flujo del Servicio Web de Detección de Generación de Frases en Lenguaje Natural}

\begin{table}[htbp]
\begin{tabular}{p{4cm}p{8cm}}
\hline
Entrada & Salida \\
\hline \hline
Corredor, perder, zapatillas & El corredor pierde unas zapatillas\\ \hline
Corredor, rápido, perder, zapatillas & El corredor rápido pierde unas zapatillas\\ \hline
Corredor, ayer, perder, zapatillas & El corredor ayer perdió unas zapatillas.\\ \hline
Corredor, mañana, perder, zapatillas & El corredor mañana perderá unas zapatillas.\\ \hline
Corredor, rápido, ayer, perder, zapatillas & El corredor rápido ayer perdió unas zapatillas.\\ \hline
Corredor, perder, zapatillas, nuevo & El corredor pierde unas zapatillas nuevas\\ \hline
Corredor, rápido, perder, zapatillas, nuevo & El corredor rápido pierde unas zapatillas nuevas\\ \hline
Corredor, rápido, ayer, perder, zapatillas, nuevo & El corredor rápido ayer perdió unas zapatillas nuevas.
\\ \hline
Corredor, rápido. perder, zapatillas, nuevo, ayer & El corredor rápido perdió unas zapatillas nuevas ayer.
\\ \hline
Este, corredor, rápido, perder, zapatillas, nuevo & Este corredor rápido ayer perdió unas zapatillas nuevas.
\\ \hline
La, corredor, rápido, perder, zapatillas, nuevo & La corredora rápida ayer perdió unas zapatillas nuevas.
\\ \hline
\end{tabular} 
\caption{Tabla con diferentes entradas y salidas del Servicio Web de Generación de Frases en Lenguaje Natural.}
\label{tabla:tiempoVerbal}
\end{table}

En la Figura \ref{fig:NLGService}, podemos ver un resumen del flujo que sigue este servicio y en la tabla \ref{tabla:tiempoVerbal} podemos varios ejemplos de entradas y salidas del servicio.
%------------------------------------------------------------------
\subsection{Servicios web para la Gestión de Pictogramas} %-------------------------------------------------------------------
\label{cap5:sec:ServiciosParaPictos}

En esta subsección pasaremos a explicar los dos servicios web, que hemos creado para tratar con pictogramas. En estos servicios hemos utilizando la API de ARASAAC\footnote{https://beta.arasaac.org/developers/api}. Ambos servicios  siguen la misma linea de ejecución, la cual se muestra en la Figura \ref{fig:serviciosAPIARAASAC}. 
\figura{Bitmap/ServiciosWeb/serviciosAPIARAASAC}{height=12cm}{fig:serviciosAPIARAASAC}{Flujo de los servicios web Para Pictogramas } 

\subsubsection{Servicio Web de Búsqueda del Pictogramas Asociados a una Palabra}
\label{cap5:sec:ServiciosParaPictosPalabra}
Este servicio web, recibe una palabra a través de una petición GET y devuelve un objeto en formato JSON, que contiene un array con los diferentes pictogramas asociados a la palabra recibida.
Este servicio lanza una petición GET con la palabra recibida al buscador de pictogramas de la API de ARAASAC\footnote{https://api.arasaac.org/api/pictograms/api/pictograms/es/search/'Nombre'}, el cual devuelve una lista de todos los pictogramas, que tienen asociada la palabra introducida.
La respuesta devuelta por la API de ARAASAC es procesada por nuestro servicio, escogiendo aquellos pictogramas que tienen asociados exclusivamente la palabra introducida. Por ejemplo si se realiza la búsqueda de la palabra huevo, la API de ARAASAC devolverá tres pictogramas uno para huevo, otro para huevo frito, y otro para huevo roto. Nuestro servicio se quedara solo con el primero, por cada pictograma nuestro servicio devuelve los siguientes atributos:
\begin{itemize}
\item Identificador del pictograma.
\item La palabra asociada al pictograma.
\item URL a la imagen del pictograma.
\end{itemize}
\figura{Bitmap/ServiciosWeb/pictoFinderResponse}{height=16cm,width=12cm}{fig:pictoFinderResponse}{Respuesta del servicio web de búsqueda del pictogramas asociados a una palabra}
Cada pictograma con sus atributos se añade a una lista que sera devuelta en el resultado de este servicio web tal y como podemos ver en la Figura \ref{fig:pictoFinderResponse}, donde podemos ver el resultado devuelto por nuestro servicio para la entrada ``cortar'', esta palabra tiene varios pictogramas asociados, los cuales podemos ver en la Figura \ref{fig:pictosCortar}.
\figura{Bitmap/ServiciosWeb/cortarPictos}{height=9cm}{fig:pictosCortar}{Diferentes pictogramas asociados a la palabra cortar}


\subsubsection{Servicio Web de Traducción de Pictogramas a Texto}
\figura{Bitmap/ServiciosWeb/finderIDAPI}{height=16cm}{fig:finderIDAPI}{Respuesta del buscador por id de la API de ARAASAC} 

Este servicio web recibe el identificador de un pictograma y devuelve las diferentes palabras asociadas al pictograma, ya que un solo pictograma puede tener varios pictogramas.En la Figura \ref{fig:finderIDAPI} podemos ver la respuesta para el Identificador 7823, que posee dos significados profesor y profesor de educación física.
Este servicio lanza una petición con el identificador recibido, al buscador de pictogramas por id de la API de ARASAAC\footnote{https://api.arasaac.org/api/pictograms/es/`idPictograma'}. En la Figura \ref{fig:finderIDAPI} podemos ver la respuesta para el Identificador 7823.

Con la respuesta de la API, se accede al atributo ``Keywords'', se encapsula dentro de un objeto, que sera la respuesta de este servicio tal y como se puede ver en la Figura \ref{fig:responseTranslatePictoService}.

\figura{Bitmap/ServiciosWeb/responseTranslatePictoService}{height=2cm}{fig:responseTranslatePictoService}{Respuesta del buscador por id de la API de ARAASAC} 


%------------------------------------------------------------------
\section{Front-End}
%-------------------------------------------------------------------
\label{cap5:sec:ComponentesAngular}

En esta sección introduciremos los diferentes servicios y componentes Angular desarrollados para la parte Front-End de la aplicación, la cual podemos ver en la Figura \ref{fig:appEscritorio}. Hemos implementado dos componentes:
\begin{itemize}
\item Buscador de pictogramas: el cual podemos ver en la Figura \ref{fig:buscadorPictogramas}, este componente sirve como entrada de pictogramas a la aplicación, en el podemos ver los diferentes pictogramas asociados a la palabra introducida además del identificador de dicho pictograma.
\item Traductor de pictogramas a lenguaje natural: podemos ver este componente en la Figura  \ref{fig:traductorPictogramas}
\figura{Bitmap/Arquitectura/traductorPictogramas}{width=9cm}{fig:traductorPictogramas}{Componente buscador de pictogramas}, este componente es el encargado de manejar los pictogramas que se van a traducir. Dentro de el podemos ver los pictogramas que formaran la frase, ordenarlos o borrar aquellos que no se desean y traducirlos a lenguaje natural.
\end{itemize}

Cabe destacar que cada uno de estos componentes posee un HTML, un controlador y un servicio de aplicación propio.  A parte de estos componentes hemos implementado una serie de útiles, como un archivo de constantes (para almacenar las diferentes direcciones de los servicios web), un servicio proxy que permite abstraer las peticiones HTTP, y por ultimo otro servicio de ventanas modales para el tratamiento de errores. Cada uno de estos servicios se explicara en detalle en las siguientes secciones.
Ademas hemos tenido en cuenta que la aplicación sea responsive y diseñado la vista para tener una versión móvil la cual se puede ver en la Figura \ref{fig:appMo}.

\figura{Bitmap/Arquitectura/appEscritorio}{height=11cm, width=13cm}{fig:appEscritorio}{Pict2Text}
\figura{Bitmap/Arquitectura/appMo}{height=15cm}{fig:appMo}{Pict2Text versión para dispositivos moviles}
\subsection{Servicio Proxy}

El servicio proxy de la aplicación sirve para abstraer las diferentes llamadas HTTP del resto de la aplicación. Este componente es necesario ya que sirve de punto de acceso a los servicios web explicados en la sección \ref{cap5:sec:backEnd}, de este capitulo. Los  métodos: \textbf{getByName()} y \textbf{postByName()} se encargan de emitir las peticiones HTTP, get y post respectivamente, esperar la respuesta del servicio web y devolverla al servicio de aplicación, al tener toda esta lógica en un solo servicio del cual hace uso toda la aplicación, aumenta la reusabilidad y el mantenimiento. 

La ventaja principal de usar un servicio proxy es que abstrae la lógica de acceso del resto de la aplicación, de manera que si los datos pasaran a estar en una base de datos habría que cambiar mucho menos lógica y además permite la  reutilización del código de las llamadas HTTP en toda la aplicación.
Cuando el servicio de aplicación de algún componente hace uso de alguno de los métodos del servicio proxy, se convierte en un subscriptor de dicho método. Gracias a la suscripción cuando el Servicio Proxy reciba la respuesta de la llamada HTTP, se encargara de avisar a sus suscriptores de que ya ha recibido la respuesta y entregarla. Esto es gracias al patrón Observer que implementa Angular en las llamadas HTTP. En caso de que la respuesta de la llamada fuera un error, el servicio proxy reintentará la llamada hasta cinco veces, si la ultima llamada falla, devuelve el error a los suscriptores. 

En la Figura \ref{fig:proxyClassDiagram} podemos ver los métodos disponibles en la clase ProxyService.
\figura{Bitmap/Arquitectura/proxyService}{height=5cm, width=7cm}{fig:proxyClassDiagram}{Diagrama de clase del Servicio Proxy}

\subsection{Servicio de Ventanas Modales}  

Este servicio tiene como finalidad mostrar los errores que hayan podido surgir a lo largo del flujo de la aplicación. El servicio de ventanas modales, es un servicio reutilizable que se inyecta en los componentes, esto nos permite abstraer toda la lógica necesaria para mostrar los errores en un solo servicio, el cual hacen uso todos los controladores de la aplicación Front-End. 
Su utilidad principal es construir y mostrar una ventana modal genérica, dado un error especifico, con el fin de dar al usuario feedback de los errores que puedan darse. 

Este servicio sigue el patrón Factory, es decir es capaz de crear objetos concretos, gracias a sus datos de entrada, utilizando una plantilla genérica, tal y como podemos ver en la figura \ref{fig:modalsError}.
\figura{Bitmap/Arquitectura/proxyService}{width=200px}{fig:proxyClassDiagram}{Diagrama de clase del Servicio Proxy}
Además de esto hemos utilizado la librería NGBoostrap\footnote{https://ng-bootstrap.github.io/} para la implementación de este servicio de ventanas modales, esta librería hace uso del patrón Singleton para las ventanas modales, y ademas abstrae toda la funcionalidad relacionada con el uso de ventanas modales, como pueda ser la lógica de abrir o cerrar la ventana. Además de la funcionalidad tiene estilos CSS propios, que ayudan a definir el tamaño de la ventana modal, el fondo que se pone sobre el body de la pagina, etc. 
Este servicio tiene dos variables de entrada el código de error y el texto asociado al error, ambos obtenidos del error devuelto por el servicio. En la Figura \ref{fig:modalErrorServiceClass}, podemos ver un diagrama que resume los métodos de la clase ErrorModalService, y muestra su dependencia con la plantilla Error-Modal.html, la cual es usada para generar las ventanas modales.
\figura{Bitmap/Arquitectura/modalErrorServiceClass}{width=200px}{fig:modalErrorServiceClass}{Diagrama del servicio de modales}

\subsection{Buscador de Pictogramas}
La utilidad principal del buscador de pictogramas es ser el punto de entrada de los pictogramas a la aplicación, dado que no existe ningún otro punto de acceso, como pueda ser un archivo con diferentes pictogramas. El componente esta formado por un input donde introducir la palabra para la que se desea buscar el pictograma y un carrusel de pictogramas que permanece oculto hasta que se busca un pictograma y que nos permite mostrar todos los pictogramas asociados con la palabra introducida .El carrusel ha sido implementado con la librería NGBoostrap.
Este componente posee un controlador, un servicio de aplicación propios y un transformer.

El controlador es el encargado de conectar el HTML de la vista, con el resto de la aplicación Angular. Tiene sirve para obtener la palabra para la que se desea buscar un pictograma que se desea buscar y enviarlo al servicio de aplicación y además añadir los pictogramas al componente traductor de pictogramas usando el botón añadir.
 
El servicio de aplicación creara la URL para hacer la llamada al servicio web de búsqueda del pictogramas asociados a una palabra (visto en la sección \ref{cap5:sec:ServiciosParaPictosPalabra}) usando el archivo de constantes. Con la URL generada llamara al Servicio Proxy, que se encargara de enviar y recibir la respuesta del servicio web. Si la respuesta es correcta el servicio de aplicación hará uso del transformer para generar un objeto para el controlador, en caso de error devolverá el error al controlador para que muestre el mensaje de error.
Podemos ver el diagrama del componente buscador de pictogramas en la Figura \ref{fig:finderClass}.    
\figura{Bitmap/Arquitectura/finderClass}{width=300px}{fig:finderClass}{Diagrama del componente buscador de pictogramas}

\subsection{Traductor de Pictogramas a Lenguaje Natural} 

Este componente sirve de contenedor del array de pictogramas que después traduciremos y para lanzar la traducción, podemos ver este componente en la Figura \ref{fig:traductorPictogramas}.
En el HTML el componente implementa un contenedor para los pictogramas, donde se muestran la frase de pictogramas, este contenedor se ha implementado usando la biblioteca Material de Angular\footnote{https://material.angular.io/}. Además el componente tiene un botón para lanzar la traducción y la sección donde se mostrara el resultado de la traducción. 
Este componente tiene un controlador y un servicio de aplicación propio.
El controlador se encarga de manejar la logica drag and drop que posee el contenedor de pictogramas, y la lógica de borrado de los pictogramas.
\figura{Bitmap/Arquitectura/translatorComponent}{width=300px}{fig:translatorComponent}{Diagrama del Traductor de Pictogramas a Lenguaje Natural}
En la Figura \ref{fig:translatorComponent}, podemos ver un diagrama que muestras las clases que forman este componente así como los archivos HTML que contienen el código de la vista.

El servicio de aplicación, tiene como parametro de entrada el array de strings que formara el cuerpo de la petición POST, además obtiene la URL del Servicio de Generación de Lenguaje del archivo de constantes, y usando estos datos llamara al servicio proxy, el cual sera encargado de lanzar la petición POST y devolver la respuesta del servicio. Una vez se obtiene la respuesta del servicio se devuelve la respuesta al controlador del componente, el cual ya sera el encargado de mostrar la traducción o mostrar la ventana de la modal de error en caso de error en la respuesta del servicio.


