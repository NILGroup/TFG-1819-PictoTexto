% !TeX encoding = ISO-8859-1


\chapter{Herramientas}
\label{cap:Herramientas}

A lo largo de este capítulo analizaremos las diferentes herramientas utilizadas para el desarrollo de este TFG, lo primero que se requiere es de un espacio donde facilitar la conexión entre los diferentes servicios web para ello utilizamos Django, la función principal de nuestro TFG es realizar un buen uso del lenguaje natural, para ello se necesita un analizador de dicho lenguaje como es Spacy y un generador de frases de lenguaje natural en este caso el elegido es Simple-NLG, para conseguir las traducciones de texto a pictogramas ha sido imprescindible el uso de la API de Arasaac.   
Por último, para agilizar tanto el tiempo de respuesta de los servidores como el proceso de comunicación de los diferentes servicios web de nuestro trabajo se ha elegido la herramienta Angular.
  

%-------------------------------------------------------------
\section{Django}
%-------------------------------------------------------------
\label{cap3:sec:Django}  
Debido a los diferentes servicios web que se utilizan en este TFG, se decidió utilizar un framework que ayudase a los programadores a crear e implementar de una manera más fácil dichos servicios web, como por ejemplo un manejador de los archivos estáticos de las rutas, host a los que se les permiten acceder a los servicios, etc. Además al ser python uno de los lenguajes de programación más utilizados en el proyecto, era aconsejable que dicho framework estuviera también desarrollado en ese mismo lenguaje. 
Con estos requisitos previos se eligió la herramienta Django, la cuál es un framework que nos permite desarrollar aplicaciones web\footnote{https://openwebinars.net/blog/que-es-django-y-por-que-usarlo/} de una manera gratuita, y de código abierto escrito en Python. Además de respetar el patrón de diseño conocido como Modelo-Vista-Controlador (M-V-C), por lo que fomenta el desarrollo rápido y un diseño limpio y pragmático. Por último Django nos permitirá implementar un software rápido, seguro, escalable y versátil.

\section{API-Arasaac}
%-------------------------------------------------------------
\label{cap3:sec:API-Arasaac}

Dado un pictograma necesitábamos conocer la palabra asociada a dicho pictograma y para eso hemos utilizado la API de Arasaac \footnote{https://beta.arasaac.org/developers/api}, centrándonos en la sección de pictogramas.
En este trabajo se han utilizado dos de los métodos proporcionados en la API, por un lado obtenemos el texto asociado a un pictograma partiendo de la propia palabra mediante el método(/pictograms/search/{searchText}), gracias a esto se logra una conexión entre el texto, su pictograma y un objeto con toda la información relevante asociada a la palabra , por ejemplo de la palabra \textit{perro} se consigue un objeto con dicha información relativa a la palabra, como puede ser: sus keywords o palabras clave, el tipo de palabra que es, los posibles plurales de dicha palabra, el significado de la misma, etc. 
 
El segundo método (/pictograms/{idPictogram}) es necesario para la parte del buscador de nuestra aplicación, ya que permite obtener la información del pictograma a partir de su id, con esto se consigue una relación entre la palabra y su pictograma gracias al código de identificación.
Siguiendo con el ejemplo anterior, si se desea buscar la palabra \textit{perro}, el método relaciona dicha palabra a su id devolviendo el pictograma asociado a ella, en este caso el id 2517. 

\section{Spacy}
%-------------------------------------------------------------
\label{cap3:sec:Spacy}
Spacy es una biblioteca escrita en Python diseñada para el procesamiento avanzado de lenguaje natural\footnote{\url{https://medium.com/datos-y-ciencia/comenzando-con-spacy-para-procesamiento-de-lenguaje-natural-e8cf24a18a5a}}.

Para el uso del lenguaje natural primero se necesitaba realizar una clasificación del tipo de palabras, es decir, clasificar dichas palabras según sean sustantivos, adjetivos, verbos,etc.
Una vez realizada esa organización se necesita realizar un análisis de los atributos de cada palabra, esto significa que dependiendo del tipo de palabra se conozca su género, número, tiempo verbal, etc.\\ 
Para esta función de análisis se eligió usar la librería Spacy por delante de otras como ClearNLP o CORENLP, esta elección se basó en poder hacer un procesamiento del lenguaje natural en castellano y ademas la precisión y velocidad cuando realiza un análisis de las palabras, como podemos observar en la figura \ref{fig:precisionSpacy} .\\

\figura{Bitmap/Herramientas/precisionSpacy}{width=200px}{fig:precisionSpacy}{Benchmark de diferentes procesadores del lenguaje, Fuente https://spacy.io/.}
    
Spacy por tanto será el encargado de proporcionarnos la información de los atributos de cada palabra analizada, mencionados en el párrafo anterior, mediante su función Tokenizer. Así con esta función obtendremos la categoría léxica de las palabras, es decir, conseguiremos conocer si la palabra es sustantivo, adjetivo, verbo, determinante, etc. Una vez conseguida su categoría léxica, Spacy nos proporciona características de cada palabra:
\begin{itemize}
    \item \textbf{Sustantivos} y \textbf{Adjetivos}, la información principal que detalla es muy parecida para ambos, proporcionando: tipo de palabra, género, número, sinónimos de la palabra, keyword o palabra clave.
    \item \textbf{Pronombres}, para los pronombres se obtiene: tipo de palabra, tipo de pronombre, número de la persona y número gramatical.
    \item \textbf{Verbos}, de Spacy se obtiene: tipo de palabra, forma verbal, tiempo verbal, keyword o palabra clave.
    \item \textbf{Determinantes}, la información que detalla es: tipo de palabra, tipo de determinante, género y número.
    \item \textbf{Adverbios}, los atributos que presenta son: tipo de palabra, tipo de adverbio, keyword o palabra clave. 
    \item \textbf{Preposiciones}, nos informa de características tales como: tipo de palabra, keyword o palabra clave.
\end{itemize}

\section{SimpleNLG-ES}
%-------------------------------------------------------------
\label{cap3:sec:SimpleNLG}
El primer motivo por el que la herramienta elegida es SimpleNLG-ES es por que es la única que está pensada para el castellano, además necesitábamos una herramienta que nos permitiese generar frases en lenguaje natural. 
Por estas razones, se eligió para realizar esta tarea a SimpleNLG-ES, una biblioteca hecha en Java que permite la generación de lenguaje natural \citep{Trzpis2015}.\\
Simple-NLG permite crear frases simples y dentro de estas se pueden formar diferentes tipos de frases, yendo desde oraciones nominales, como por ejemplo: ``la casa roja'', hasta aquellas que posean al menos un verbo conocidas como oraciones verbales, por ejemplo: ``mi perro es negro''. Dependiendo del tipo de frase, la oración se forma de una u otra forma:
\begin{itemize}
    \item \textbf{Frases simples o nominales}. Cuando la frase no tiene ningún verbo, SimpleNLG-ES comienza generando el sustantivo de la frase añadiendo a dicho sustantivo el determinante que concuerde con el género y número del sustantivo, dichas informaciones se deben introducir como datos de entrada. Una vez creado el sustantivo con su determinante correspondiente, la herramienta permite añadirle complementos, como pueden ser: adjetivos, adverbios, etc. Para ejemplo mencionado anteriormente ``La casa roja'', el sustantivo introducido será ``casa'', el género y el número serán femenino y singular, SimpleNLG-ES genera con dicho género y número el determinante asociado ``la'' y por último añadirá el complemento del sustantivo introducido ``roja''.    
    \item \textbf{Oraciones verbales}. Estos tipos de oraciones se pueden diferenciar como mínimo tres partes, por un lado está la parte del sujeto, la segunda parte que se analiza es el verbo de la oración y por el último el resto de complementos del predicado, haciendo la generación del lenguaje en esta ocasión de la siguiente manera:
    \begin{itemize}
    \item Sujeto. Se genera de la misma forma que en las frases nominales, por ejemplo ``mi perro''.
    \item Verbo.SimpleNLG-ES no es capaz de reconocer cuál es el verbo por si solo, por tanto hace falta indicarlo a la herramienta, una vez encontrado el verbo recogerá la información relevante a la forma y tiempo verbal en los que viene dados, es decir, si el tiempo al que se refiere es pasado, presente o futuro y además la persona y el número con el que conjugar el verbo lo obtendrá del sujeto al que acompaña. Con todos estos datos, SimpleNLG-ES generará dicho verbo en su forma mas adecuada, siguiendo el ejemplo puesto antes, generará el verbo en el tiempo presente y en tercera persona ``es''.
    \item Complementos. Una vez generados tanto el sujeto como el verbo, se pasa a completar el resto de complementos del predicado, para ello como datos de entrada recibirá los tipos de palabras que conforman dicho predicado, es decir, si son sustantivos, adjetivos, adverbios, etc. Generando las palabras del mismo, y haciendo que concuerden en género y número aquellas palabras que califiquen al sujeto, como pueden ser los adjetivos. Por ejemplo ``negro'' que tiene el mismo género y número que el sujeto de la oración. 
    \end{itemize}
\end{itemize}
Por último, es importante destacar que Simple-NLG nos permite también negar oraciones o formar directamente oraciones negativas.
    
\section{Angular}
%-------------------------------------------------------------
\label{cap3:sec:Angular}
El motivo principal por el que se ha decidido utilizar la herramienta Angular es el de dotar de una mayor rapidez a nuestra aplicación. 
Angular es un framework de desarrollo creado y mantenido por Google, cuya finalidad consiste en el desarrollo de aplicaciones web SPA (Single-Page Applications), es decir, interacción web con una sola página web, lo que provoca que la aplicación sea más rápida, dinámica y fluida. 
Angular se encargará del lado frontend de la aplicación haciendo cada parte de la página web independiente. 
  
Para realizar la parte frontend de nuestra aplicación se estudiaron las diferentes herramientas que se podrían utilizar, en un primer momento se pensó en extender la herramienta Django para la parte del cliente, pero dicha herramienta ofrecía ciertas limitaciones en esta parte, por tanto se descartó esa idea.
La segunda alternativa fue la opción de introducir JQuery, esta segunda opción tampoco era la más idónea ya que se trata de una librería orientada a acceder y modificar los elementos de la página y no para gestionar el uso de diferentes servicios, algo esencial en este proyecto.
La última opción y al final la escogida fue la de implantar dentro de nuestro trabajo Angular, ya que era la alternativa que más funcionalidades aportaba y de las analizadas la más orientada a gestionar diferentes servicios en una misma página.
Además la herramienta está formado por diferentes módulos distintos unos de otros y estos a su vez están formados por diferentes componentes, ofreciendo una división automática del código para que los usuarios solo carguen aquellas componentes que necesitan nuestro proyecto se han creado dos totalmente independientes como puede ser el buscador de pictogramas o el componente de traductor de pictogramas, estos dos módulos se podrían integrar por separado en cualquier otra aplicación.

Por último, otro punto importante a favor de angular es su capacidad de proporcionar una actualización automática de la información, es decir, si se modifica algún almacén de datos Angular realiza automáticamente dichos cambios. 
Sin embargo, esto conlleva un coste bastante elevado en cuánto al rendimiento y para solucionar este problema fue por lo que se usó un patrón llamado ``Observable'' \footnote{\url{https://desarrolloweb.com/articulos/introduccion-teorica-observables-angular.html}}. 

El patrón Observable es un modo de implementación de la programación reactiva, esta programación es aquella que se encarga de los flujos de datos asíncronos. Esto quiere decir, que es el encargado de producir y distribuir el flujo de los distintos eventos o llamadas y consumirlos. Las componentes principales de este patrón son:
\begin{itemize}
    \item \textbf{Observable}. Es aquello que el programador desea observar, un observable puede ser un formulario creado por un usuario, una llamada HTTP, un almacén de datos, etc. Además permite la modificación de aquello que se esta observando.  
    \item \textbf{Observer}. Es el que se dedica a observar, principalmente está basado en un colección de funciones callback, que permiten escuchar los eventos o llamadas emitidos por un observable.
    \item \textbf{Subject}. Se trata del emisor de los eventos o llamadas, es el encargado de crear los flujos cuando el observable realiza algún cambio, y comunicarlos al observer. 
\end{itemize} 
Es importante mencionar, que la librería que usa Angular para utilizar este patrón es la RxJS, la cuál es una librería de Microsoft que se utiliza para la programación reactiva, creando aplicaciones que usan el patrón observer para gestionar operaciones asíncronas. 

 


