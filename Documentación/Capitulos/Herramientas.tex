% !TeX encoding = ISO-8859-1


\chapter{Herramientas}
\label{cap:Herramientas}

A lo largo de este capítulo analizaremos las diferentes herramientas utilizadas para el desarrollo de este TFG.

%-------------------------------------------------------------
\section{Django}
%-------------------------------------------------------------
\label{cap3:sec:Django}

Es un framework de desarrollo web\footnote{https://tutorial.djangogirls.org/es/django/} de código abierto escrito en Python, respetando el patrón de diseño conocido como Modelo-Vista-Controlador (M-V-C). La meta principal de esta aplicación es facilitar la creación de sitios web. En Django es muy importante el re-uso de código, la conectividad y el desarrollo rápido.\\  
\begin{enumerate}
\item Django da soporte de base de datos permitiendo crear los modelos de datos necesarios y a través de su API administrar y gestionar dicha base de datos. Además concede al usuario la posibilidad de poder ejecutar sus propias consultas SQL.
\item En la parte de servicios Web, Django incluye un servidor ligero que ofrece la posibilidad de realizar pruebas y trabajar en una etapa de desarrollo. Para una etapa más de producción sería más conveniente contar con otra aplicación como puede ser Apache.
\end{enumerate}

\section{GSON}
%-------------------------------------------------------------
\label{cap3:sec:GSON}
GSON es una librería open-source la cuál nos permite convertir nuestros objetos Java en JSON o viceversa, esta librería es muy importante ya que nos permite poder obtener un objeto GSON compatible con el servicio web configurado en lenguaje Java. Al estar nuestro Servicio web configurado en formato REST, este hecho obliga a que este servicio tenga que recibir obligatoriamente un JSON.

Esta librería es un framework que contiene en su interior el método "from JSON", dicho método es vital para la obtención de un objeto compatible con nuestro servicio.

Una vez obtenidos el objeto GSON mencionado, la propia librería se encarga de realizar el resto de la conversión y madarlo al Servicio web para que funcione correctamente.

\section{Apache Tomcat}
%-------------------------------------------------------------
\label{cap3:sec:Apache Tomcat} 
En el lado del servidor se ha decidido utilizar Apache Tomcat, el cuál funciona como un entorno que sirve para distribuir aplicaciones servlets\footnote{\url{https://www.oracle.com/technetwork/java/javaee/servlet/index.html}}. El tipo servlets es una clase de lenguaje Java utilizada principalmente para ampliar las capacidades propias de un servidor.

El servidor se encarga de analizar cada palabra de la frase y conecte con la API de Arasaac   con el fin de buscar los pictogramas correspondientes. El resultado obtenido es devuelto al servidor encapsulado en un objeto GSON.\\ 
La versión de Apache utilizada es la 9.0.14,para acceder al servicio de traducción del proyecto hay que introducir la siguiente dirección en el buscador: http://127.0.0.1:8080.

\section{SpaCy}
%-------------------------------------------------------------
\label{cap3:sec:SpaCy}
SpaCy es una biblioteca de procesamiento del lenguaje natural diseñado en Python diseñada específicamente con el objetivo de ser una biblioteca útil para implementar sistemas listos para producción\footnote{\url{https://medium.com/datos-y-ciencia/comenzando-con-spacy-para-procesamiento-de-lenguaje-natural-e8cf24a18a5a}}.
Además es una librería relativamente nueva sobresaliendo por su facilidad de uso y su velocidad a la hora de realizar el procesamiento del texto.






\section{SimpleNLG-ES}
%-------------------------------------------------------------
\label{cap3:sec:SimpleNLG}

La herramienta SimpleNLG-ES es una biblioteca Java que permite generar y transformar texto. Tiene como fin producir texto comprensible para el usuario \citep{Trzpis2015}.\\
El simpleNLG-ES crea palabras añadiendoles distintas características con la función CreateWord, la cual se encuentra integrada dentro de la factoria NLG, dicha factoria permite crear diferentes tipos de frases. 
Dependiendo de la complejidad de las oraciones que se quieran crear se utilizarán diferentes procedimientos, en nuestro caso utilizamos el procedimiento NounPhrases (frases nominales).
Además con la función mencionada anteriormente, podemos hacer que cada palabra contenga una categorización léxica, es decir el simpleNLG clasifica cada palabra introducida en diferentes categorías. Por ejemplo:
\begin{enumerate} 
\item Con la característica léxica "NOUN". Si introducimos la palabra "perro" en la oración, la herramienta lo categoriza como nombre.
\item Sin embargo, con la característica léxica "ANY". Introducimos una palabra sin especificar su tipo. 
\end{enumerate} 

La sentencia "Features" del SimpleNLG-ES permite definir las características de cada palabra, esta opción es muy importante ya que la herramienta coge la raíz sintáctica de las palabras que analiza y gracias a estas features la propia herramienta especifica el género y número de cada palabra.
Por ejemplo, "Corredora", SimpleNLG coge su raíz (corredor) y con la terminación "a" especifica el género: femenino y el número: singular de la palabra.
Una vez especificado el género y número de los sustantivos de las oraciones, una vez conocido tanto el genero y el número de la palabra la herramienta es capaz de añadirle el determinante que le corresponda al sustantivo.  

La sentencia SPhraseSpec, permite diferenciar automáticamente las partes sintácticas de la oración. Así , en la frase "mi perro come pan" la clasificación resultante sería.
Para comprobar si clasifica correctamente la oración del ejemplo, podemos usar: 
\begin{enumerate}  
\item  Devolverá "mi perro" como el sujeto de la oración.
\item  "Come" será el verbo de la  misma.
\item  Y "pan" como el complemento.
\end{enumerate}

En lo referente a los verbos, SimpleNLG es capaz de especificar tanto la forma como el tiempo verbal, para todo esto utilizamos como antes la sentencia "feature", aunque al tratarse de verbos las características que especifica son diferentes a la de los sustantivos.
Una de estas características es la de obtener el tiempo del verbo, es decir, podemos obtener si su tiempo esta en \underline {pasado}, \underline {presente} o \underline {futuro}, entre otros.
Otra de las características que permite la herramienta es la de añadirle al verbo su forma negativa, para poder formar así oración negativas.

Por último es importante destacar la función "realiser" el cuál es el encargado de juntar las diferentes partes sintácticas en un objeto que devolverá la oración analizada. 


\section{API-Arasaac}
%-------------------------------------------------------------
\label{cap3:sec:API-Arasaac}

Para conseguir la traducción de cada pictograma hemos utilizado la propia API de Arasaac \footnote{https://beta.arasaac.org/developers/api}, centrándonos principalmente en la parte de obtención de pictogramas, como podemos observar en la  Figura \ref{fig:principal}\figura{Bitmap/Herramientas/PrincipalAPI}{width=300px}{fig:principal}{Presentación de la API de Arasaac}.

En el apartado de pictogramas se han utilizado dos de los métodos "GET", por un lado la obtención del pictograma mediante su id (/pictograms/{locale}/{idPictogram}), mirar figura \ref{fig:principal}. 
Por ejemplo para el id (2517) obtenemos que es el pictograma de la palabra "perro", tal y como se muestra en la Figura \ref{fig:APIperro}
\figura{Bitmap/Herramientas/APIperro}{width=300px}{fig:APIperro}{Código obtenido del pictograma con la palabra "perro"}.

El otro método "GET" que se ha utilizado para nuestro proyecto es para poder buscar el texto para relacionarlo con el pictograma que deseamos (/pictograms/{locale}/search/{searchText}), mirar figura \ref{fig:principal}. 
Este método nos devuelve un objeto con todo lo relacionado con el texto buscado, siguiendo el ejemplo anterior con la palabra "perro", obtenemos el objeto que se muestra en la Figura \ref{fig:perroProyecto}\figura{Bitmap/Herramientas/APIperroProyecto}{width=300px}{fig:perroProyecto}{Información del objeto con la palabra "perro"}.\\
Por tanto, gracias a la API de Arasaac hemos podido conseguir toda la parte de codificación necesaria para poder implementar en nuestro TFG la obtención de pictogramas y la relación entre una palabra y su pictograma.  
  

 


