% !TeX encoding = ISO-8859-1


\chapter{Herramientas}
\label{cap:Herramientas}

A lo largo de este capítulo analizaremos las diferentes herramientas utilizadas para el desarrollo de este TFG. Para implementar todas las funciones necesarias de la aplicación vamos a utilizar diferentes servicios web.\\
Lo primero es conseguir las palabras asociadas a cada pictograma del mensaje de entrada por ello haremos uso de la API de Arasaac, como veremos en la sección \ref{cap3:sec:API-Arasaac}. Para generar frases gramaticales correctas a partir de las palabras asociadas a los pictogramas del mensaje introducido vamos a necesitar, un generador de lenguaje natural como es SimpleNLG, contado en la sección \ref{cap3:sec:SimpleNLG} y un analizador sintáctico como Spacy, ver sección \ref{cap3:sec:Spacy}.\\
Una vez obtenidas las herramientas necesarias para la generación de las frases, se requiere de un espacio donde facilitar la conexión entre los diferentes servicios web para ello utilizamos Django, observar en la sección \ref{cap3:sec:Django}, por último, para agilizar tanto el tiempo de respuesta de los servidores como el proceso de comunicación de los diferentes servicios web de nuestro trabajo se ha elegido la herramienta Angular, como podemos ver en la sección \ref{cap3:sec:Angular}.

%-------------------------------------------------------------  
\section{API-Arasaac}
%-------------------------------------------------------------
\label{cap3:sec:API-Arasaac}

En nuestra aplicación los pictogramas son fundamentales y necesitábamos una herramienta que nos permitiese:
\begin{itemize}
    \item Obtener los pictogramas asociados a una determinada palabra.
    \item Obtener la palabra o palabras asociada aun pictograma.
\end{itemize}
Para ello hemos empleado la API de Arasaac \footnote{https://beta.arasaac.org/developers/api}, ya que de todos los sistemas pictográficos vistos en la sección \ref{cap2:sec:Pictogramas}, los pictogramas de Arasaac son los más utilizados en los países hispanohablantes.
Además ofrece multitud de herramientas gratuitas y como hemos venido comprobando están muy desarrolladas.\\
De todos los métodos ofrecidos por la API de Arasaac hemos usado principal 2:
\begin{itemize}
    \item SearchText: Sacado del método (/pictograms/search/{searchText}, en el que dad una palabra devuelve todos los pictogrmas asociados a ella.Por ejemplo, dada la palabra dicho método nos devuelve un JSON con su información, como podemos observar en la Figura \ref{fig:jsonPerro}.

\figura{Bitmap/Herramientas/jsonPerro}{width=12cm}{fig:jsonPerro}{JSON con la información de la palabra perro, Fuente https://beta.arasaac.org/developers/api.}
    \item idPictogram: En este segundo método (/pictograms/{idPictogram}), es donde dado un identificador de un pictograma devuelve un JSON con toda la información asociada a la palabra la cuál se identifica con dicho id, en este caso con el id 2517, se obtiene un JSON con la información de \textit{perro}
\end{itemize} 

La API de Arasaac es gratuita con fines no comerciales, siempre que en la aplicación se mencione explícitamente a Arasaac y se cumpla la licencia CC (Creative Commons) RY-NC-SA \footnote{https://creativecommons.org/licenses/by-nc-sa/3.0/es/}.

\section{SimpleNLG}
%-------------------------------------------------------------
\label{cap3:sec:SimpleNLG}
Para la aplicación se necesitaba un generador de frases gramaticales y además que dicho generador estuviera pensado para traducir al castellano, la única herramienta que cumplía con estos requisitos era SimpleNLG, una biblioteca hecha en Java que permite la generación de lenguaje natural \citep{Trzpis2015}.
Simple-NLG permite crear frases simples y dentro de estas se pueden formar tanto oraciones nominales, como por ejemplo: ``la casa roja'' u  oraciones verbales, por ejemplo: ``mi perro es negro''. Dependiendo del tipo de frase, la oración se forma de una u otra forma:
\begin{itemize}
    \item \textbf{Oraciones nominales}. Cuando la frase no tiene ningún verbo, SimpleNLG comienza generando el sustantivo de la frase añadiendo a dicho sustantivo el determinante que concuerde con él en género y número, dichas informaciones que acabamos de mencionar se deben introducir como datos de entrada. Una vez creado el sustantivo con su determinante correspondiente, la herramienta permite añadirle complementos, como pueden ser: adjetivos, adverbios, etc. Por ejemplo si queremos generar la frase ``La casa roja'', debemos proporcionar a SimplNLG el sustantivo (``casa''), el género (femenino) y el número (singular) y el complemento del sustantivo (``roja'').    
    \item \textbf{Oraciones verbales}. Estos tipos de oraciones tienen tres partes, el sujeto, el verbo y el predicado:
    \begin{itemize}
    \item Sujeto: Se genera de la misma forma que en las frases nominales.
    \item Verbo:Para generarlo debemos proporcionar a SimpleNLG el verbo en infinitivo y el tiempo verbal al que se refiere pasado, presente o futuro.
Además el género y número para la conjugación del verbo lo genera de manera automática SimpleNLG a partir de la información del sujeto.
    \item Complementos. Para generar el predicado debemos proporcionar a SimpleNLG las palabras que lo componen junto con el tipo de palabra que es cada una (sustantivos, adjetivos, adverbios..). Con toda esta información, SimpleNLG genera el predicado gramatical correcto. 
    \end{itemize}
Por ejemplo, para la frase ``mi perro es negro'', el sujeto (``mi perro''), el verbo (``es'') y el complemento (``negro''). 
\end{itemize}
Por último, es importante destacar que Simple-NLG nos permite introducir las negaciones a las oraciones junto con otras muchas funcionalidades que quedan fuera del ámbito de nuestro estudio.

\section{Spacy}
%-------------------------------------------------------------
\label{cap3:sec:Spacy}
Spacy es una biblioteca escrita en Python diseñada para el procesamiento avanzado de lenguaje natural\footnote{\url{https://medium.com/datos-y-ciencia/comenzando-con-spacy-para-procesamiento-de-lenguaje-natural-e8cf24a18a5a}}.

Una vez que transformamos los pictogramas en palabras, se necesita conocer la categoría lexica de cada una de esas palabras (sustantivo, verbo, adjetivo...)con sus correspondientes géneros y números para las palabras que se necesiten y así poder generar una frase gramatical correcta.  
Para esta función de análisis usamos la librería Spacy.Esta elección se basó en que es la herramienta que posee una mayor precisión en la traducción que realiza, como se puede observar en la Figura \ref{fig:precisionSpacy} .\\

\figura{Bitmap/Herramientas/precisionSpacy}{width=200px}{fig:precisionSpacy}{Benchmark de diferentes procesadores del lenguaje, Fuente https://spacy.io/.}

La clase Tokenizer de Spacy es la encargada de dividir el mensaje recibido en palabras y de cada palabra informarnos de su categoría, (sustantivos, adjetivos, pronombres, verbos, determinantes, adverbios, preposiciones, conjunciones o complementos).Junto con las siguientes características de cada palabra:   
\begin{itemize}
    \item \textbf{Sustantivos} y \textbf{Adjetivos}. Género, número, sinónimos y keyword o palabra clave (palabra a la que se refiere).
    \item \textbf{Pronombres}. Tipo de pronombre (personales, demostrativos, indefinidos, posesivos), número de la persona (si es un pronombre personal o posesivo devuelve el número de la persona al que hace referencia) y número gramatical (si es singular o plural).
    \item \textbf{Verbos}.Forma verbal(infinitivo, gerundio o participio), tiempo verbal(pasado, presente o futuro), keyword o palabra clave (palabra a la que se refiere).
    \item \textbf{Determinantes}. Tipo de determinante(artículos, posesivos, numerales), género y número.
    \item \textbf{Adverbios}. Tipo de adverbio (lugar, tiempo, cantidad, modo) y keyword o palabra clave (palabra a la que se refiere). 
    \item \textbf{Preposiciones}, \textbf{Conjunciones} y \textbf{Complementos}. keyword o palabra clave (palabra a la que se refiere).
\end{itemize}

\section{Django}
%-------------------------------------------------------------
\label{cap3:sec:Django}  
Cada funcionalidad que se utiliza en este TFG ha sido implementada como un servicio web, por ello se decidió utilizar un framework que ayudase a los programadores a crear, e implementar de una manera más fácil dichos servicios web, además estos servicios  están escritos en Python ya que es el lenguaje de programación más usado para el procesamiento de lenguaje natural (PLN) y además es open source, era aconsejable que dicho framework estuviera también desarrollado en ese mismo lenguaje.\\ 
Con estos requisitos previos se eligió la herramienta Django, la cuál nos permite desarrollar aplicaciones web\footnote{https://openwebinars.net/blog/que-es-django-y-por-que-usarlo/} de código abierto y gratuitas escritas en Python, Django te da la capacidad de: poseer un manejador para los archivos estáticos de las rutas, host sobre los que se pueden acceder a los servicios, plantillas en las que basarnos para crear nuestra aplicación y unos modelos que nos proporcionan los mecanismos para poder añadir, modificar o borrar en dicha aplicación. Además respeta el patrón de diseño conocido como Modelo-Vista-Controlador (M-V-C), por lo que fomenta el desarrollo rápido y un diseño limpio y pragmático. Por último Django nos permitirá implementar un software rápido, seguro, escalable y versátil.
    
\section{Angular}
%-------------------------------------------------------------
\label{cap3:sec:Angular}
El motivo principal por el que se ha decidido utilizar la herramienta Angular es para gestionar toda la parte frontend de nuestra aplicación haciendo cada parte de la página web independiente. Angular es un framework de desarrollo creado y mantenido por Google, cuya finalidad consiste en el desarrollo de aplicaciones web SPA (Single-Page Applications), es decir, interacción web con una sola página web, lo que provoca que la aplicación sea más rápida, dinámica y fluida. 
  
Para realizar esta parte frontend de nuestra aplicación se estudiaron las diferentes herramientas que se podrían utilizar, en un primer momento se pensó en extender la herramienta Django para la parte del cliente, pero dicha herramienta está pensada principalmente para la gestión de la parte backend, por tanto se descartó esa idea.
La segunda alternativa fue la opción de introducir JQuery, esta segunda opción tampoco era la más idónea ya que se trata de una librería orientada a acceder y modificar los elementos de la página y no para gestionar el uso de diferentes servicios, algo esencial en este proyecto.
La última opción y al final la escogida fue la de implantar dentro de nuestro trabajo Angular, ya que era la alternativa que más funcionalidades aportaba y de las analizadas la más orientada a gestionar diferentes servicios en una misma página.
Además la herramienta está formado por diferentes módulos distintos unos de otros y estos a su vez están formados por diferentes componentes, ofreciendo una división automática del código para que los usuarios solo carguen aquellas componentes que necesitan, además es módulos son completamente reutilizables, permitiendo así cumplir uno de los objetivos que nos planteamos al principio, poder hacer nuestro trabajo lo más independiente y reutilizable posible.

Por último, otro punto importante a favor de angular es su capacidad de proporcionar una actualización automática de la información, es decir, si se modifica algún almacén de datos Angular realiza automáticamente dichos cambios. 
Sin embargo, esto conlleva un coste bastante elevado en cuánto al rendimiento y para solucionar este problema fue por lo que se usó un patrón llamado ``Observable'' \footnote{\url{https://desarrolloweb.com/articulos/introduccion-teorica-observables-angular.html}}. 

El patrón Observable es un modo de implementación de la programación reactiva, esta programación es aquella que se encarga de los flujos de datos asíncronos. Esto quiere decir, que es el encargado de producir y distribuir el flujo de los distintos eventos o llamadas y consumirlos. Las componentes principales de este patrón son:
\begin{itemize}
    \item \textbf{Observable}. Es aquello que el programador desea observar, un observable puede ser un formulario creado por un usuario, una llamada HTTP, un almacén de datos, etc. Además permite la modificación de aquello que se esta observando.  
    \item \textbf{Observer}. Es el que se dedica a observar, principalmente está basado en un colección de funciones callback, que permiten escuchar los eventos o llamadas emitidos por un observable.
    \item \textbf{Subject}. Se trata del emisor de los eventos o llamadas, es el encargado de crear los flujos cuando el observable realiza algún cambio, y comunicarlos al observer. 
\end{itemize} 
Es importante mencionar, que la librería que usa Angular para utilizar este patrón es la RxJS, la cuál es una librería de Microsoft que se utiliza para la programación reactiva, creando aplicaciones que usan el patrón observer para gestionar operaciones asíncronas. 

 


