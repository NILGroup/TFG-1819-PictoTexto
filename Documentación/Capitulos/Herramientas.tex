% !TeX encoding = ISO-8859-1


\chapter{Herramientas}
\label{cap:Herramientas}

A lo largo de este capítulo analizaremos las diferentes herramientas utilizadas para el desarrollo de este TFG. Para implementar todas las funcionalidades de la aplicación vamos a utilizar servicios web.
Lo primero es conseguir las palabras asociadas a cada pictograma del mensaje de entrada para ello haremos uso de la API de Arasaac, que explicaremos en la Sección \ref{cap3:sec:API-Arasaac}. Para generar frases gramaticalmente correctas a partir de las palabras asociadas a los pictogramas vamos a necesitar un generador de lenguaje natural como es SimpleNLG, (Sección \ref{cap3:sec:SimpleNLG}) y un analizador sintáctico como Spacy, (sección \ref{cap3:sec:Spacy}).
Una vez obtenidas las herramientas necesarias para la generación de las frases, necesitamos un espacio donde facilitar la conexión entre los diferentes servicios web, para ello utilizamos Django, que será explicado en la Sección \ref{cap3:sec:Django}. Por último, para agilizar tanto el tiempo de respuesta de los servidores como el proceso de comunicación de los diferentes servicios web de nuestro trabajo se ha elegido la herramienta Angular para implementar el Front-End de nuestra aplicación, presentado en la Sección \ref{cap3:sec:Angular}.

%-------------------------------------------------------------  
\section{API-Arasaac}
%-------------------------------------------------------------
\label{cap3:sec:API-Arasaac}

En nuestra aplicación los pictogramas son fundamentales y necesitábamos una herramienta que nos permitiese:
\begin{itemize}
    \item Obtener los pictogramas asociados a una determinada palabra.
    \item Obtener la palabra o palabras asociadas a un pictograma.
\end{itemize}
Para ello hemos empleado la API de Arasaac\footnote{https://beta.arasaac.org/developers/api}, ya que de todos los sistemas pictográficos vistos en la Sección \ref{cap2:sec:Pictogramas}, los pictogramas de Arasaac son los más utilizados en los países hispanohablantes.
Además, Arasaac ofrece multitud de herramientas gratuitas.\\
De todos los métodos ofrecidos por la API de Arasaac hemos usado los siguientes:
\begin{itemize}
    \item SearchText\footnote{/pictograms/search/searchText}: Dada una palabra devuelve todos los pictogramas asociados a ella.Por ejemplo, dada la palabra nos devuelve el JSON. Dicho JSON contiene toda la información relevante a dicha palabra, tipo de palabra, significado, sinónimos, plurales y keyword o palabra por la que se traduce, mostrado en la Figura \ref{fig:jsonPerro}.
\figura{Bitmap/Herramientas/jsonPerro}{width=12cm}{fig:jsonPerro}{JSON devuelto por el método SearchText para la palabra perro, Fuente https://beta.arasaac.org/developers/api.}

    \item idPictogram\footnote{/pictograms/idPictogram}: Dado un identificador de un pictograma devuelve un JSON con toda la información asociada a la palabra la cuál se identifica con dicho id, por ejemplo con el id 2549, se obtiene un JSON con la información de \textit{reloj}, tal y como se muestra en la Figura \ref{fig:jsonReloj}
\figura{Bitmap/Herramientas/jsonReloj}{width=12cm}{fig:jsonReloj}{JSON devuelto por el método IdPictogram para el identificador 2549, Fuente https://beta.arasaac.org/developers/api.}
\end{itemize} 

La API de Arasaac es gratuita con fines no comerciales, siempre que en la aplicación se mencione explícitamente a Arasaac y se cumpla la licencia CC (Creative Commons) RY-NC-SA \footnote{https://creativecommons.org/licenses/by-nc-sa/3.0/es/}.

\section{SimpleNLG}
%-------------------------------------------------------------
\label{cap3:sec:SimpleNLG}
Para la aplicación se necesitaba un generador de frases gramaticalmente correctas en castellano. La única herramienta que cumplía con estos requisitos era SimpleNLG, una biblioteca hecha en Java que permite la generación de lenguaje natural \citep{Trzpis2015}.
Simple-NLG permite crear frases simples y dentro de estas se pueden crear tanto oraciones nominales, como por ejemplo: ``la casa azul'' u  oraciones verbales, como: ``mi perro es negro''. Dependiendo del tipo de frase, la oración se forma de una u otra forma:
\begin{itemize}
    \item \textbf{Oraciones nominales}. Cuando la frase no tiene ningún verbo, SimpleNLG comienza generando el sustantivo de la frase y añadiendo a dicho sustantivo el determinante que concuerde con él en género y número. Para ello se le debe proporcionar a SimpleNLG el sustantivo de la oración como dato de entrada y la herramienta añadirá automáticamente el determinante que concuerde en género y número con él. Una vez creado el sustantivo con su determinante correspondiente, la herramienta permite añadirle complementos, como pueden ser: adjetivos, adverbios, etc. Por ejemplo si queremos generar la frase ``La casa azul'', debemos proporcionar a SimplNLG el sustantivo (``casa''), el género (femenino) y el número (singular) y el complemento del sustantivo (``azul'').    
    \item \textbf{Oraciones verbales}. Estos tipos de oraciones tienen tres partes, el sujeto, el verbo y el predicado:
    \begin{itemize}
    \item Sujeto: Se genera de la misma forma que en las frases nominales.
    \item Verbo: Para generarlo debemos proporcionar a SimpleNLG el verbo en infinitivo y el tiempo verbal al que se refiere (pasado, presente o futuro).
El género y el número para la conjugación del verbo lo genera de manera automática SimpleNLG a partir de la información del sujeto.
    \item Complementos. Para generar el predicado debemos proporcionar a SimpleNLG las palabras que lo componen junto con su categoría léxica (sustantivo, adjetivo, adverbio..). Con toda esta información, SimpleNLG genera un predicado gramaticalmente correcto. 
    Por ejemplo, para generar la frase ``mi perro es negro'', deberíamos proporcionar a SimpleNLG el sujeto (``mi perro''), el verbo (``ser'') y el complemento (``negro''). 
    \end{itemize}
\end{itemize}
Por último, es importante destacar que SimpleNLG nos permite introducir negaciones en las oraciones junto con otras muchas funcionalidades que quedan fuera del ámbito de nuestro trabajo.

\section{Spacy}
%-------------------------------------------------------------
\label{cap3:sec:Spacy}
Una vez que transformamos los pictogramas en palabras, se necesita conocer la categoría lexica de cada una de esas palabras (sustantivo, verbo, adjetivo...) así como su género y número para poder generar una frase gramatical correcta. Para esta función de análisis usamos la librería Spacy.\\
Esta elección se basó en que es la herramienta que posee una mayor precisión en la traducción, como se puede observar en la Figura \ref{fig:precisionSpacy} .\\

\figura{Bitmap/Herramientas/precisionSpacy}{width=12cm, height=4cm}{fig:precisionSpacy}{Benchmark de diferentes procesadores del lenguaje, Fuente https://spacy.io/.}

Spacy es una biblioteca escrita en Python diseñada para el procesamiento avanzado de lenguaje natural\footnote{https://medium.com/datos-y-ciencia/comenzando-con-spacy-para-procesamiento-de-lenguaje-natural-e8cf24a18a5a}.

La clase Tokenizer de Spacy es la encargada de dividir el mensaje recibido en palabras y de informarnos de la categoría (sustantivo, adjetivo, pronombre, verbo, determinante, adverbio, preposiciones, conjunciones o complementos) de cada palabra, junto con las siguientes características según la categoría:   
\begin{itemize}
    \item \textbf{Sustantivos} y \textbf{Adjetivos}. Género, número, sinónimos.
    \item \textbf{Pronombres}. Tipo de pronombre (personal, demostrativo, indefinido, posesivo), número de la persona (si es un pronombre personal o posesivo devuelve el número de la persona a la que hace referencia).
    \item \textbf{Verbos}.Forma verbal(infinitivo, gerundio o participio), tiempo verbal (pasado, presente o futuro).
    \item \textbf{Determinantes}. Tipo de determinante (artículo, posesivo, numeral), género y número.
    \item \textbf{Adverbios}. Tipo de adverbio ( de lugar, de tiempo, de cantidad, de modo). 
    \item \textbf{Preposiciones}, \textbf{Conjunciones} y \textbf{Complementos}.

En la Figura \ref{fig:palabrasSpacy}, podemos observar un ejemplo del análisis que realiza Spacy de cada palabra.
\figura{Bitmap/Herramientas/palabrasSpacy}{width=6cm}{fig:palabrasSpacy}{Ejemplo del análisis de cada palabra hecho por Spacy, Fuente https://spacy.io/.} 
\end{itemize}

\section{Django}
%-------------------------------------------------------------
\label{cap3:sec:Django}  
Cada funcionalidad que se utiliza en este TFG ha sido implementada como un servicio web, por ello se decidió utilizar un framework que ayudase a los programadores a crear, e implementar de una manera más fácil y eficiente dichos servicios web. Además estos servicios  están escritos en Python ya que es el lenguaje de programación más usado para el Procesamiento de Lenguaje Natural (PLN) por lo que es aconsejable que dicho framework estuviera también desarrollado en Python. 
Con estas restricciones en mente se eligió la herramienta Django, la cuál nos permite desarrollar aplicaciones web\footnote{\url{https://openwebinars.net/blog/que-es-django-y-por-que-usarlo/}} de código abierto y gratuitas escritas en Python. Django proporciona: un manejador para los archivos estáticos de las rutas, un host sobre el que se puede acceder a los servicios, plantillas en las que basarnos para crear la aplicación. Además respeta el patrón de diseño conocido como Modelo-Vista-Controlador (M-V-C), por lo que fomenta el desarrollo rápido y un diseño limpio y pragmático.
    
\section{Angular}
%-------------------------------------------------------------
\label{cap3:sec:Angular}
Angular se ha usado para gestionar toda la parte Front-End de nuestra aplicación haciendo cada parte de la página web independiente.\\ 
Angular es un framework de desarrollo creado y mantenido por Google, cuya finalidad consiste en el desarrollo de aplicaciones web SPA (Single-Page Applications), es decir, interacción web con una sola página, lo que provoca que la aplicación sea más rápida, dinámica y fluida. 
  
Para realizar la parte Front-End de nuestra aplicación se estudiaron diferentes herramientas. En un primer momento se pensó en extender la herramienta Django para la parte del cliente, pero dicha herramienta está pensada principalmente para la gestión de la parte Back-End y por tanto se descartó esta idea.
La segunda alternativa fue introducir JQuery, esta segunda opción tampoco era la más idónea ya que se trata de una librería orientada a acceder y modificar los elementos de la página, pero carece de la facilidad que otorga Angular al utilizar componentes, aplicar patrones de arquitectura y sobretodo la rapidez y facilidad de Angular para el tratamiento de llamadas asíncronas.
Por estos motivos decidimos usar Angular, ya que era la alternativa que más funcionalidad, rapidez y escalibilidad, aporta de las herramientas analizadas.

Además, Angular nos permitía crear nuestra aplicación por componentes\footnote{\url{https://angular.io/guide/architecture-components}}, ofreciendo así una división del código. Los componentes tienen la ventaja de ser completamente independientes unos de otros y ser reutilizables, esta independencia que poseen los componentes otorgan una gran flexibilidad a la hora de construir aplicaciones, aumentan la escalabilidad y facilitan el mantenimiento.

Otro punto importante a favor del uso de Angular es su capacidad de proporcionar una actualización automática de la información, es decir, los datos mostrados en la vista están actualizados gracias al uso del modelo\footnote{\url{https://angular.io/guide/displaying-data}}. 

El problema que conlleva este tipo de servicios asíncronos es que no sigue un orden definido en el tiempo de respuesta de cada llamada, la solución que realizó angular con este problema fue implantar el patrón `Observer''\footnote{\url{https://desarrolloweb.com/articulos/introduccion-teorica-observables-angular.html}}.

El patrón Observable es un patron de programación reactiva, utilizado para la resolución de llamadas asíncronas como puedan ser llamadas HTTP. Esto quiere decir, que es el encargado de producir y distribuir el flujo de los distintos eventos o llamadas y consumirlos. Las componentes principales de este patrón son:
\begin{itemize}
    \item \textbf{Observable}. Es aquello que el programador desea observar, un observable puede ser un formulario creado por un usuario, una llamada HTTP, un almacén de datos, etc. Además permite la modificación de aquello que se esta observando.  
    \item \textbf{Observer}. Es el que se dedica a observar, principalmente está basado en un colección de funciones callback, que permiten escuchar los eventos o llamadas emitidos por un observable.
    \item \textbf{Subject}. Se trata del emisor de los eventos o llamadas, es el encargado de crear los flujos cuando el observable realiza algún cambio, y comunicarlos al observer. 
\end{itemize} 
Es importante mencionar, que la librería que usa Angular para utilizar este patrón es la RxJS(Reactive Extensions for JavaScript)\footnote{https://angular.io/guide/rx-library}, una librería centrada en el paradigma de la programación reactiva, la cual otorga diferentes ayudas para la resolución de llamadas asíncronas.

 


