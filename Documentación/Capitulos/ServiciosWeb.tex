% !TeX encoding = ISO-8859-1

\chapter{Servicio Web para la traducción de pictogramas a texto}
\label{cap:serviciosWeb}
	
A lo largo de este capitulo se presentaran los diferentes servicios web, que hemos implementado, para la traducción de mensajes con pictogramas. En la Sección \ref{cap5:sec:Arquitectura} presentaremos la arquitectura de la aplicación y los diferentes principios en los que nos hemos basado para su implementación.

%------------------------------------------------------------------
\section{Arquitectura}
%-------------------------------------------------------------------
\label{cap5:sec:Arquitectura}

El trabajo de este TFG está englobado dentro del proyecto nacional IDiLyCo\footnote{http://nil.fdi.ucm.es/index.php?q=projects/idilyco}. IDiLyCo es un proyecto que busca facilitar la inclusión digital, de aquellas personas que por diversidad   funcional, tienen problemas con el lenguaje natural. Uno de los objetivos del proyecto es desarrollar pequeñas piezas de funcionalidad reutilizables que se combinan en diferentes aplicaciones, es por ello que  debiamos diseñar una arquitectura con muy bajo acoplamiento. Por esa razón hemos decidido utilizar una arquitectura orientada a servicios en la parte back-end, y a componentes en la parte front-end. En ambas casos aplicando, hemos seguido los principios de responsabilidad única (Single Responsability Principle)\footnote{https://devexperto.com/principio-responsabilidad-unica/}, segregación de la interfaz (Interface Segregation Principle)\footnote{https://hackernoon.c
om/interface-segregation-principle-bdf3f94f1d11}, y de inversión de dependencias (Dependency inversion principle).
Estos tres principios forman parte de SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion), descritos por Robert C. Martin\citep{martin2013agile}. Los principales objetivos de los 5 principios SOLID son:
\begin{itemize}
\item Crear un producto software de calidad que sea robusto.
\item Producir código ordenado y limpio dando además una gran flexibilidad buscando que sea reutilizable y facilmente mantenible gracias al bajo acomplamiento que se consigue
\item Permitir la escalabilidad, gracias a una alta modularidad obtenida por la separación de responsabilidades.
\end{itemize}

Nuestra arquitectura se basa en los siguientes principios de SOLID:

\begin{itemize}

\item El principio de responsabilidad única, promueve la separación de las clases para promover que cada clase haga una sola cosa, y no dependa de un tercero. Cada clase debe de ser responsable únicamente de su comportamiento y no tener dependencia de un tercero. Un ejemplo de violación de este principio es cuando en una misma clase, están involucradas dos capas diferentes de la arquitectura. Además este principio promueve la creación de múltiples clases muy simples, con lógica mínima, en contra de una clase con una lógica mayor, ya que está ultima produce un fuerte acoplamiento y disminuye la sostenibilidad del código. Por ejemplo en nuestro proyecto todos los Servicios Web, están organizados por diferentes clases, donde cada Servicio Web es independiente uno del otro.

\item El principio de segregación de la interfaz, es muy parecido al principio de responsabilidad única, ya que este principio busca abstraer lo máximo posible las interfaces de todas las clases, para así poder re-aprovecharlas en otras clases. Un ejemplo es la interfaz de peticiones de la aplicación angular donde todos los componentes de la aplicación hacen uso de la misma clase para lanzar las peticiones a los servicios web.

\item Principio de inversión de dependencias, consiste en evitar dependencias externas dentro del código, y que el código central de las aplicaciones no dependa de frameworks, de bases de datos o del como se conecten los diferentes servicios entre ellos. Normalmente se habla de que las clases de alto nivel no deben de depender de las clases de bajo nivel\footnote{https://devexperto.com/principio-de-inversion-de-dependencias/}, un ejemplo de esto en nuestra aplicación es el uso de Servicios Web, que reciben tipos básicos y devuelven los resultados en formato JSON.

\end{itemize}

El Servicio Web de Generación de Lenguaje Natural, utiliza Apache TomCat como contenedor, para encapsular la librería SimpleNLG-ES, y poder ser accesible desde el servicio web principal o cualquier otro servicio web del proyecto IDiLyCo\footnote{http://nil.fdi.ucm.es/index.php?q=projects/idilyco}.


%------------------------------------------------------------------
\section{Servicio Clasificación De Palabras}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioClasificaciónDePalabras}

El Servicio Clasificación De Palabras \footnote{/translate/getWordAttrs}, es accesible tanto por el método GET\footnote{/translate/getWordAttrs?word=`NombrePalabra'}, como por el método POST, en la Figura \ref{fig:attrsRequest} podemos ver una llamada a este servicio con la palabra ``casa". Su finalidad es utilizando la librería Spacy, crear un objeto que devuelva la categoría léxica ( nombre, verbo, adjetivo...) y las características que Spacy devuelva, como puede ser el genero o el número, de la palabra o palabras que recibe, tal y como podemos en la Figura \ref{fig:attrsResponse}.
Una vez se lee la palabra de entrada, en caso de que sea una petición GET, o el array de palabras en caso de una petición POST, se carga el modulo de SpaCy del cual ya hemos hablado en el capitulo \ref{cap3:sec:SpaCy}, posteriormente el modelo de palabras en español, y obtenemos el token de cada una de las palabras recibidas. 
Tratamos los dados devueltos por el token y creamos el objeto que formara la respuesta, el cual contendrá la palabra con sus características, tal y como se ve en la Figura \ref{fig:attrsResponsePost}
\figura{Bitmap/ServiciosWeb/attrsRequest}{width=300px}{fig:attrsRequest}{Llamada al servicio web de clasificación de palabras}
\figura{Bitmap/ServiciosWeb/attrsResponse}{width=300px}{fig:attrsResponse}{Respuesta del servicio de búsqueda de pictogramas para la palabra casa} 
\figura{Bitmap/ServiciosWeb/attrsResponsePost}{width=400px}{fig:attrsResponsePost}{Respuesta del Servicio Web de Clasificación de Palabras a una petición POST} 

%------------------------------------------------------------------
\section{Servicio de Detección de Tiempo Verbal}
%-------------------------------------------------------------------
\label{cap5:sec:ServiciodeDeteccióndeTiempoVerbal}

Servicio de Detección de Tiempo Verbal \footnote{/translate/getTypePhrase}, recibe una petición POST, con una lista de palabras,al igual que el Servicio Web de Clasificación de Palabras. Después de recibir la petición busca palabras clave en la lista de palabras recibida. Si detecta alguna palabra clave, devuelve en un JSON con el tipo de frase que se debe de generar, tal y como podemos ver en la Figura \ref{fig:getTypeResponse}. 
El servicio permite clasificar frases tanto en pasado, como en futuro y presente en caso de no haber ninguna palabra clave.
  
\figura{Bitmap/ServiciosWeb/getTypeResponse}{width=300px}{fig:getTypeResponse}{Servicio de Detección de Tiempo Verbal} 

%------------------------------------------------------------------
\section{Servicio de Generación de Lenguaje Natural}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioGLN}

Como ya hemos hablado anteriormente, hemos utilizado la librería SimpleNLG-ES\footnote{https://github.com/citiususc/SimpleNLG-ES}.
El servicio de generación de lenguaje natural \footnote{/NLGWebService/createPhrase}
) recibe un JSON con un array de strings, tal y como podemos ver en la Figura \ref{fig:nlgResponse}, y su finalidad es devolver una frase con las palabras recibidas en la llamada. En la Figura \ref{fig:nlgRequest} podemos ver la respuesta de este servicio a la llamada de las palabras ``perro, rápido, comer, pan, duro".

\figura{Bitmap/ServiciosWeb/responseTranslateService}{width=300px}{fig:nlgResponse}{Petición al servicio de creación del lenguaje}
\figura{Bitmap/ServiciosWeb/translateService}{width=300px}{fig:nlgRequest}{Respuesta del servicio de creación del lenguaje}


Una vez el servidor recibe la petición Post, la librería GSON se encarga de parsear la entrada para convertir el JSON de entrada en un ArrayList de Strings. Este paso es necesario dado que Java reconoce los JSON como una cadena de texto, y utilizando esta librería podemos conseguir una clase implementada usando un JSON y el tipo de clase Java representado por el JSON.

Cuando la entrada es transformada de manera correcta, se llama al Servicio Web de Clasificación de Palabras, a través de una petición POST, y usando también una petición POST con los mismos datos se llama al Servicio Web de Detección de Tiempo Verbal, y de esa manera obtenemos el tiempo verbal en el que se debe conjugar la frase.

Gracias al resultado de esta clasificación podemos determinar la posición del verbo, con lo cual podemos dividir la lista de palabras en aquellas que formaran el sujeto (aquellas que están antes del verbo) y aquellas que formaran el objecto (palabras encontradas después del verbo).

Una vez identificadas las palabras que forman parte del sujeto se pasa a procesar el sujeto de la frase. En este proceso se configura un determinante en caso de que sea necesario, es decir si es un nombre común por ejemplo ``corredor, perro, bailarina", por defecto el determinante es \textit{ el o la},por ejemplo ``corredora,rapido'' generara ``La corredora rapida''.En palabra principal sea un determinante como ``el, ella, nosotros", no se añade ningún determinante. Además, se obtiene el genero y numero del nombre principal del sujeto, para proceder a la configuración de los mismos de todo el sujeto, de manera que si el nombre es femenino plural como por ejemplo ``mujeres, contento'' el sujeto resultante sera ''Las mujeres contentas''.

De la misma manera que con el sujeto, se recorre el array de palabras objeto, y si se encuentran palabras de categoría léxica ``nombre'' se configura la parte objeto del predicado utilizando el genero y numero obtenido. De manera que si el array está formado por las palabras ``galletas, duro'' el resultado sera `` galletas duras''.

El tiempo verbal de la frase se escoge, dependiendo de la respuesta del Servicio de Detección de Tiempo Verbal. Diferenciamos tres tipos de respuesta,
pasado, futuro y presente que es la configuración de tiempo verbal por defecto.

En caso de encontrar un adverbio se fuerza su posición al final de la frase que formara el objeto, si se encuentra dentro del array de palabras objecto,  de manera que si las palabras que conformaran la frase final contienen ``profesora,comer,ayer,galletas,duro'', la frase resultante sera ``La profesora comío galletas duras ayer''. En caso de encontrar el adverbio dentro del array de palabras del sujeto se pondrá al final del sujeto, y así la entrada ``profesora ayer,comer,galletas,duro'' generara la frase ``La profesora ayer comío galletas duras''


Una vez tenemos todos las partes de la frase se pasa a la realización de la misma. Se detecta si existen predicados y el objeto de la frase, y en caso de que existan se añaden a la frase, se forma la frase final gracias a SimpleNLG, está fase se denomina realización, el resultado de está fase sera devuelto en la respuesta del servicio tal y como podemos ver en la Figura \ref{fig:nlgRequest}, para la entrada ``perro, rápido, comer, pan, duro''.
A continuación repasaremos otros ejemplos de entradas:
\begin{itemize}
\item Entrada simple sujeto, verbo, objeto (Profesor,comer,galletas
\item Entrada con adjetivo en el sujeto, adjetivo, verbo, objeto: ''Profesor, listo, comer, galletas'' -> ``El profesor listo come galletas''
\item Entrada con adverbio en el sujeto, adverbio, verbo, objeto: ''Profesor, ayer, comer, galletas'' -> ''El profesor ayer comió galletas''
\item Entrada con adjetivo y adverbio temporal en el sujeto: sujeto, adjetivo, adverbio, verbo, objeto: ''Profesor, listo, ayer, comer, galletas'' -> ''El profesor listo ayer comió galletas''
\item Entrada con adjetivo en el predicado: sujeto, verbo, objeto, adjetivo: ''Profesor, comer, galletas, duro'' -> ''El profesor come galletas duras''
\item Entrada con adverbio en el predicado: sujeto, verbo, adverbio temporal, objeto: ''Profesor, comer, galletas, ayer'' -> ''El profesor comió galletas ayer''
\item Entrada con adjetivo y adverbio en el predicado, adverbio, adjetivo, verbo, objeto: ''Profesor, comer, galletas, duro, ayer'' -> ''El profesor commió galletas duras ayer''
\end{itemize}

%------------------------------------------------------------------
\section{Servicios para la gestión de pictogramas} %-------------------------------------------------------------------
\label{cap5:sec:ServiciosParaPictos}

Para la obtención de los pictogramas, así como su significado se han implementado una serie de servicios web que hacen uso de la API de ARASAAC\footnote{https://beta.arasaac.org/developers/api}. 
En esta subsección pasaremos a desarrollar los diferentes servicios web, que utilizamos para llamar a la API de ARASAAC, y crear las respuestas necesarias:

\subsection{Servicio web de búsqueda}

Este servicio web\footnote{/picto/getPicto?pictoName=`NombrePictograma'}, recibe una palabra a través de una petición GET tal y como podemos ver en la Figura \ref{fig:pictoFinderRequest}, y devuelve un objeto en formato JSON.
\figura{Bitmap/ServiciosWeb/pictoFinderRequest}{width=400px}{fig:pictoFinderRequest}{Petición al servicio de búsqueda de pictogramas}
Este servicio lanza una petición GET a un servicio web externo\footnote{https://api.arasaac.org/api/pictograms/api/pictograms/es/search/'Nombre'} de la API de ARAASAC, el cual devuelve una lista de pictogramas. La respuesta devuelta por la API de ARAASAC es procesada para quedarnos con los siguientes datos de cada pictograma: identificador del pictograma, la URL al archivo con la imagen asociado al pictograma de ARASAAC y el significado. A continuación se crea una lista con todos los pictogramas y sus datos y se genera un JSON que sera la salida del servicio.

\figura{Bitmap/ServiciosWeb/pictoFinderResponse}{width=300px}{fig:pictoFinderResponse}{Respuesta del servicio de búsqueda de pictogramas para la palabra casa}

\subsection{Servicio web de traducción}

Este segundo servicio web tiene diferentes end-points, accesibles desde /translate:

Servicio de traducción de pictogramas\footnote{/translate/getPictoTranslate?pictoId='XXXX'} recibe el identificador de un pictograma tal y como podemos ver en la Figura \ref{fig:translateResponse} y obtiene todos los significados de dicho pictograma haciendo uso de una llamada a la API de ARASAAC de busqueda de pictogramas por id\footnote{https://api.arasaac.org/api/pictograms/es/`idPictograma'}. Encapsula dentro de un objeto los valores necesarios obtenidos de la respuesta del servicio de ARAASAC, y lo devuelve dentro de un JSON, tal y como podemos ver en la Figura  \ref{fig:responsetranslateService}.
\figura{Bitmap/ServiciosWeb/translateService}{width=300px}{fig:translateResponse}{Llamada al servicio web de traducción de pictogramas, para el pictograma 2317}
\figura{Bitmap/ServiciosWeb/responsetranslateService}{width=300px}{fig:responsetranslateService}{Respuesta del servicio de traducciones de pictogramas}


%------------------------------------------------------------------
\section{Componentes Angular}
%-------------------------------------------------------------------
\label{cap5:sec:ComponentesAngular}

En esta sección introduciremos los diferentes componentes Angular desarrollados para la parte Front-End de la aplicación. Hemos implementado diferentes componentes: un buscador de pictogramas, un traductor de pictograma por id, y el componente traductor de pictogramas, que sirve de contenedor para los diferentes pictogramas que vamos a traducir. Cabe destacar que cada uno de estos componentes posee un HTML, controlador y servicio de aplicación propio.  A parte de estos componentes hemos implementado una serie de útiles, como un archivo de constantes, para almacenar las diferentes direcciones de los servicios web, un servicio proxy que permite abstraer las peticiones HTTP, y por ultimo otro servicio de modales para el tratamiento de errores.


\subsection{Servicio Proxy}

El servicio proxy de la aplicación Angular sirve para abstraer las diferentes llamadas HTTP del resto de la aplicación, sus métodos se encargan de enviar las peticiones HTTP que se necesitan (GET o POST) y esperar la respuesta del servicio y devolverla al servicio de aplicación que le ha llamado gracias al uso del patrón Observer. Gracias a este patrón todos aquellas clases que llaman al cualquier método del proxy se convierten en subscriptores del mismo, y cuando el proxy recibe la respuesta de los servicios web se encargar de avisar a los subscriptores de que tienen la respuesta y dársela. Además de esto en caso de fallo en la llamada, el proxy volverá a lanzarla hasta cinco veces, cuando la quinta falla devuelve el error a sus subscriptores. En la Figura \ref{fig:proxyClassDiagram} podemos ver un diagrama de clases del servicio proxy.

\figura{Bitmap/ServiciosWeb/proxyService}{width=200px}{fig:proxyClassDiagram}{Diagrama de clase del Servicio Proxy}

\subsection{Servicio de modales}  

El servicio de modales, es un componente reusable que se inyecta en los componentes que tienen una parte visual. Su utilidad principal es lanzar una modal genérica, dado un error especifico. Sigue el patrón Factory, dado que su utilidad es crear objetos específicos gracias a sus datos de entrada, tal y como podemos ver en la Figura \ref{fig:errorModalExample}. Además de esto hemos utilizado la libreria NGBoostrap\footnote{https://ng-bootstrap.github.io/} para la implementación de este servicio de modales, esta librería hace uso del patron Singleton para las modales, y ademas abstrae todos la funcionalidad relacionada con el uso de modales, como pueda ser la lógica de abrir o cerrar la modal. Además de la funcionalidad tiene estilos CSS propios, que ayudan a definir el tamaño de la modal, el fondo que se pone sobre el body de la pagina etc. 
Este servicio tiene dos variables de entrada el codigo de error y el texto asociado al error, ambos obtenidos del error devuelto por el servicio. En la Figura \ref{fig:modalErrorServiceClass}
\figura{Bitmap/ServiciosWeb/modalErrorServiceExample}{width=200px}{fig:errorModalExample}{Ejemplo de modal para un error del tipo 404}
\figura{Bitmap/ServiciosWeb/modalErrorServiceClass}{width=200px}{fig:modalErrorServiceClass}{Diagrama de clase del servicio de modales}

\subsection{Buscador de pictogramas}
Este componente tiene la utilidad principal de ser un punto de entrada para los pictogramas. En la vista podemos ver un input donde introducir el nombre del pictograma que se desea buscar. Una vez seleccionada la palabra o palabras que se desean buscar, el controlador del buscador, llamara al servicio de aplicación el cual generara la URL usando el archivo de constantes de la aplicación y llamara al servicio proxy, que se encargara de enviar y recibir la respuesta del servicio web. Una vez el servicio de aplicación tiene la respuesta, se encarga de tratarla. En caso de error, sube la excepción hasta el controlador el cual llamara al servicio de modales, para informar al usuario del error. En caso de que la respuesta del servicio web sea correcta, el servicio de aplicación del buscador se encargara de tratarla, y generar un objecto para el controlador, utilizando el transformer del componente. Una vez el controlador tiene el objeto final muestra un carousel de pictogramas, implementado gracias a la librería NGBoostrap. Este carousel nos permitirá añadir imágenes al componente, traductor de pictogramas, gracias a una variable bindeada (pictoPhrase) entre los dos componentes. 
Podemos ver un diagrama de clase de todo el componente buscador en la Figura \ref{fig:finderClass}    
\figura{Bitmap/ServiciosWeb/finderClass}{width=300px}{fig:finderClass}{Diagrama de clase del componente buscador de pictogramas}

\subsection{Traductor de pictogramas} 

El traductor de pictogramas sigue la misma estructura interna que el buscador de pictogramas, eliminando el transformador tal y como podemos ver en la Figura \ref{fig:translatorComponent}. Este componente tiene el array de pictogramas que después traduciremos, y sirve para lanzar la traducción.
El componente implementa un contenedor para los pictogramas, donde se muestran todos los pictogramas que forman la frase, este contenedor de pictogramas ha sido implementado utilizando la biblioteca Material de Angular\footnote{https://material.angular.io/}. Esta biblioteca nos permite entre otras cosas implementar este contenedor, que tiene drag and drop dentro de sus elementos, lo cual nos permite ordenar los pictogramas una vez añadidos. Además hemos añadido un boton de borrar elementos, para eliminar aquellos pictogramas que se hayan añadido por error, o simplemente para poder hacer diferentes traducciones.
\figura{Bitmap/ServiciosWeb/translatorComponent}{width=300px}{fig:translatorComponent}{Diagrama de clase del componente traductor}

Dada la simplicidad de la respuesta del servicio de generación de lenguaje, este componente carece de un transformador para tratar la respuesta. El controlador de este componente recorre la lista de pictogramas del contenedor, y guarda en una lista el significado de cada uno de los pictogramas y le envía al servicio de aplicación del traductor esta lista.
El servicio de aplicación genera el cuerpo de la petición POST y carga la URL del servicio de generación de lenguaje del archivo de constantes, y llama al servicio proxy el cual sera encargado de lanzar la petición POST y devolverle la respuesta del servicio.
A diferencia del componente buscador de pictogramas, en caso de que la respuesta del servicio sea positiva se obtiene el cuerpo de la respuesta y se devuelve al controlador el cual sera el encargado de mostrar el resultado.

\subsection{Traductor de pictogramas por id}

Este componente es el más básico de los implementados, utiliza la misma arquitectura que el componente del traductor de pictogramas, tal y como podemos ver en la Figura \ref{fig:IdPictogramTranslator}.
Este componente tiene como finalidad obtener las diferentes traducciones de un pictograma, gracias al identificador de ese pictograma, el cual es recogido del input por el controlador, para seguir el flujo llamando a su servicio de aplicación, el cual generara la URL con el identificador del pictograma y la URL del servicio web de traducción de pictogramas por id, y llama al proxy el cual se encargara de lanzar la petición GET y devolver la respuesta del servicio. Dado que la respuesta del servicio es muy sencilla hemos decidido omitir el transformador y en el mismo servicio de aplicación obtener el string de significados y devolverlo al controlador el cual sera el encargado de mostrarlo por pantalla al usuario.


\figura{Bitmap/ServiciosWeb/IdPictogramTranslator}{width=300px}{fig:IdPictogramTranslator}{Diagrama de clase del componente traductor de pictogramas por id}
