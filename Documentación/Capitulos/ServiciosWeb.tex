% !TeX encoding = ISO-8859-1

\chapter{Servicio Web para la traducción de pictogramas a texto}
\label{cap:serviciosWeb}
	
A lo largo de este capitulo se presentaran los diferentes servicios web, que hemos implementado, para la traducción de mensajes con pictogramas. En la Sección \ref{cap5:sec:Arquitectura} presentaremos la arquitectura de la aplicación y los diferentes principios en los que nos hemos basado para su implementación.

%------------------------------------------------------------------
\section{Arquitectura}
%-------------------------------------------------------------------
\label{cap5:sec:Arquitectura}

El trabajo de este TFG está englobado dentro del proyecto nacional IDiLyCo\footnote{http://nil.fdi.ucm.es/index.php?q=projects/idilyco}. IDiLyCo es un proyecto que busca facilitar la inclusión digital, de aquellas personas que por diversidad   funcional, tienen problemas con el lenguaje natural. Uno de los objetivos del proyecto es desarrollar pequeñas piezas de funcionalidad reutilizables que se combinan en diferentes aplicaciones, es por ello que  debiamos diseñar una arquitectura con muy bajo acoplamiento. Por esa razón hemos decidido utilizar una arquitectura orientada a servicios en la parte back-end, y a componentes en la parte front-end. En ambas casos aplicando, hemos seguido los principios de responsabilidad única (Single Responsability Principle)\footnote{https://devexperto.com/principio-responsabilidad-unica/}, segregación de la interfaz (Interface Segregation Principle)\footnote{https://hackernoon.com/interface-segregation-principle-bdf3f94f1d11}, y de inversión de dependencias (Dependency inversion principle).
Estos tres principios forman parte de SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion), descritos por Robert C. Martin\citep{martin2013agile} y que buscan una alta modularidad y bajo acoplamiento entre los diferentes componentes de un producto software. Nuestra arquitectura se basa en los siguientes principios de SOLID:

\begin{itemize}

\item El principio de responsabilidad única, promueve la separación de las clases para promover que cada clase haga una sola cosa, y no dependa de un tercero. Cada clase debe de ser responsable únicamente de su comportamiento y no tener dependencia de un tercero. Un ejemplo de violación de este principio es cuando en una misma clase, están involucradas dos capas diferentes de la arquitectura. Además este principio promueve la creación de múltiples clases muy simples, con lógica mínima, en contra de una clase con una lógica mayor, ya que está ultima produce un fuerte acoplamiento y disminuye la sostenibilidad del código. Por ejemplo en nuestro proyecto todos los Servicios Web, están organizados por diferentes clases, donde cada Servicio Web es independiente uno del otro.

\item El principio de segregación de la interfaz, es muy parecido al principio de responsabilidad única, ya que este principio busca abstraer lo máximo posible las interfaces de todas las clases, para así poder re-aprovecharlas en otras clases. Un ejemplo es la interfaz de peticiones de la aplicación angular donde todos los componentes de la aplicación hacen uso de la misma clase para lanzar las peticiones a los servicios web.

\item Principio de inversión de dependencias, consiste en evitar dependencias externas dentro del código, y que el código central de las aplicaciones no dependa de frameworks, de bases de datos o del como se conecten los diferentes servicios entre ellos. Normalmente se habla de que las clases de alto nivel no deben de depender de las clases de bajo nivel\footnote{https://devexperto.com/principio-de-inversion-de-dependencias/}, un ejemplo de esto en nuestra aplicación es el uso de Servicios Web, que reciben tipos básicos y devuelven los resultados en formato JSON.

\end{itemize}

El Servicio Web de Generación de Lenguaje Natural, utiliza Apache TomCat como contenedor, para encapsular la librería SimpleNLG-ES, y poder ser accesible desde el servicio web principal o cualquier otro servicio web del proyecto IDiLyCo\footnote{http://nil.fdi.ucm.es/index.php?q=projects/idilyco}.


%------------------------------------------------------------------
\section{Servicio Clasificación De Palabras}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioClasificaciónDePalabras}

El Servicio Clasificación De Palabras (/translate/getWordAttrs?word), es accesible tanto por el método GET, como por el método POST, en la Figura \ref{fig:attrsRequest} podemos ver una llamada a este servicio con la palabra ``casa´´. Su finalidad es utilizando la librería Spacy, crear un objeto que devuelva la categoría léxica ( nombre, verbo, adjetivo...) y las características que Spacy devuelva, como puede ser el genero o el número, de la palabra o palabras que recibe, tal y como podemos en la Figura \ref{fig:attrsResponse}.
Una vez se lee la palabra de entrada, en caso de que sea una petición GET, o el array de palabras en caso de una petición POST, se carga el modulo de SpaCy del cual ya hemos hablado en el capitulo \ref{cap3:sec:SpaCy}, posteriormente el modelo de palabras en español, y obtenemos el token de cada una de las palabras recibidas. 
Tratamos los dados devueltos por el token y creamos el objeto que formara la respuesta, el cual contendrá la palabra con sus características, tal y como se ve en la Figura \ref{fig:attrsResponsePost}
\figura{Bitmap/ServiciosWeb/attrsRequest}{width=300px}{fig:attrsRequest}{Llamada al servicio web de clasificación de palabras}
\figura{Bitmap/ServiciosWeb/attrsResponse}{width=300px}{fig:attrsResponse}{Respuesta del servicio de búsqueda de pictogramas para la palabra casa} 
\figura{Bitmap/ServiciosWeb/attrsResponsePost}{width=400px}{fig:attrsResponsePost}{Respuesta del Servicio Web de Clasificación de Palabras a una petición POST} 

%------------------------------------------------------------------
\section{Servicio de Detección del Tiempo Verbal}
%-------------------------------------------------------------------
\label{cap5:sec:ServiciodeDeteccióndelTiempoVerbal}

Servicio de tiempo verbal ( /translate/getTypePhrase ): recibe una petición POST, con una lista de palabras ya clasificadas, tal y como podemos observar en la Figura \ref{fig:getTypeRequest}. Después de recibir la petición busca palabras clave en la lista de palabras recibida. Si detecta alguna palabra clave, devuelve en un JSON con el tipo de frase que se debe de generar, tal y como podemos ver en la Figura \ref{fig:getTypeResponse}.  
  
\figura{Bitmap/ServiciosWeb/getTypeRequest}{width=400px}{fig:getTypeRequest}{Respuesta del servicio de búsqueda de pictogramas para la palabra casa} 
\figura{Bitmap/ServiciosWeb/getTypeResponse}{width=220px}{fig:getTypeResponse}{Llamada al servicio web de clasificación de palabras}


%------------------------------------------------------------------
\section{Servicio de Generación de Lenguaje Natural}
%-------------------------------------------------------------------
\label{cap5:sec:ServicioGLN}

Como ya hemos hablado anteriormente, hemos utilizado la librería SimpleNLG-ES\footnote{https://github.com/citiususc/SimpleNLG-ES}.
Este servicio web recibe un JSON con un array de strings, tal y como podemos ver en la Figura \ref{fig:nlgResponse}, y su finalidad es devolver una frase con las palabras recibidas en la llamada. En la Figura \ref{fig:nlgRequest} podemos ver la respuesta de este servicio a la llamada de las palabras ``perro, rápido, comer, pan, duro´´.

\figura{Bitmap/ServiciosWeb/responseTranslateService}{width=300px}{fig:nlgResponse}{Petición al servicio de creación del lenguaje}
\figura{Bitmap/ServiciosWeb/translateService}{width=300px}{fig:nlgRequest}{Respuesta del servicio de creación del lenguaje}


Una vez el servidor recibe la petición Post, la librería GSON se encarga de parsear la entrada para convertir el JSON en un ArrayList de Strings, dado que Java reconoce los JSON como una cadena de texto, y utilizando esta librería podemos obtener una clase implementada usando el JSON en formato string y el tipo de clase que se desea obtener.
Una vez la entrada está transformada de manera correcta, se llama al Servicio Web de Clasificación de palabras, a traves de una petición POST


Con el resultado de esta clasificación podemos determinar la posición del verbo, con lo cual podemos dividir la lista de palabras en aquellas que formaran el sujeto y aquellas que formaran el objecto y el verbo. Cabe destacar que SimpleNLG, al generar los objectos palabras, desecha tanto el genero como el numero, los cuales se añaden a posteriori. 

\subsection{Sujeto}

Una vez tenemos el subarray de palabras ya clasificadas que formaran el sujeto se pasa a procesar el sujeto de la frase. En este proceso se configura un determinante en caso de que sea necesario, por defecto el determinante es \textit{ el o la}. Además se reconoce el genero y numero del nombre principal del sujeto, para proceder a la configuración de los mismos de todo el sujeto. 

\subsection{Objeto}

De la misma manera que con el sujeto, se recorre el sujeto añadiendo una a una las palabras como complemento del objeto, para después añadirlo a la frase.

\subsection{Tiempo verbal}

El tiempo verbal de la frase se escoge, dependiendo de la llamada que  reciba el servicio. Existen tres end-points :  /createSimplePhrase en la Figura \ref{fig:simplePhrase} podemos ver una petición para generar una  frase en presente, /createFuturePhrase en la Figura \ref{fig:futurePhrase} una llamada para frases en futuro y por ultimo la llamada a /createPastPhrase para crear una frase en pasado, en la Figura  \ref{fig:simplePhrase} podemos ver un ejemplo de esta.

\figura{Bitmap/ServiciosWeb/presentPhrase}{width=400px}{fig:simplePhrase}{Petición de creación de frase simple en presente}
\figura{Bitmap/ServiciosWeb/FuturePhrase}{width=400px}{fig:futurePhrase}{Petición de creación de frase simple en futuro}
\figura{Bitmap/ServiciosWeb/pastPhrase}{width=400px}{fig:pastPhrase}{Petición de creación de frase simple en pasado}

\subsection{Realización y envió}

Una vez tenemos todos las partes de la frase se pasa a la realización de la misma. Se detecta si existen predicados y el objeto de la frase, y en caso de que existan se añaden a la frase, se forma la frase final gracias a SimpleNLG, está fase se denomina realización, el resultado de está fase se guarda en una variable la cual se devolverá en la respuesta del servicio.


%------------------------------------------------------------------
\section{Servicios Web en Django}
%-------------------------------------------------------------------
\label{cap5:sec:ServiciosDjango}

Para la obtención de los pictogramas, así como su significado se han implementado una serie de servicios web que hacen uso de la API de ARASAAC\footnote{https://beta.arasaac.org/developers/api}. Estos servicios se han desarrollado usando el FrameWork Django, del cual ya hemos hablado anteriormente.
A continuación pasaremos a desarrollar los diferentes servicios web desarrollados:

\subsection{Servicio web de búsqueda}

Este servicio web (/picto/getPicto?pictoName='NombrePictograma'), recibe una palabra a través de una petición GET tal y como podemos ver en la Figura \ref{fig:pictoFinderRequest}, y devuelve un objeto en formato JSON.
\figura{Bitmap/ServiciosWeb/pictoFinderRequest}{width=400px}{fig:pictoFinderRequest}{Petición al servicio de búsqueda de pictogramas}
Este servicio lanza una petición GET a un servicio web externo de la API de ARAASAC, el cual devuelve una lista de pictogramas. Esta respuesta es tratada, filtrando y obteniendo aquellos datos que son realmente necesarios, para crear una lista de objetos. Cada objeto tendrá un identificador de un pictograma, asociado a la palabra recibida, de la base de datos de ARASAAC, la URL al archivo de imagen alojado en los servidores de ARASAAC y el significado de ese pictograma. Una vez toda la información es tratada y se crea la lista de objetos, se genera un JSON que se devuelve en la respuesta del servicio.

\figura{Bitmap/ServiciosWeb/pictoFinderResponse}{width=300px}{fig:pictoFinderResponse}{Respuesta del servicio de búsqueda de pictogramas para la palabra casa}

\subsection{Servicio web de traducción}

Este segundo servicio web tiene diferentes end-points, accesibles desde /translate:

Servicio de traducción de pictogramas (/translate/getPictoTranslate?pictoId='XXXX'): recibe el identificador de un pictograma tal y como podemos ver en la Figura \ref{fig:translateResponse} y obtiene todos los significados de dicho pictograma haciendo uso de una llamada a la API de ARASAAC. Encapsula dentro de un objeto los valores necesarios obtenidos de la respuesta del servicio de ARAASAC, y lo devuelve dentro de un JSON, tal y como podemos ver en la Figura  \ref{fig:responsetranslateService}.
\figura{Bitmap/ServiciosWeb/translateService}{width=300px}{fig:translateResponse}{Llamada al servicio web de traducción de pictogramas, para el pictograma 2317}
\figura{Bitmap/ServiciosWeb/responsetranslateService}{width=300px}{fig:responsetranslateService}{Respuesta del servicio de traducciones de pictogramas}
